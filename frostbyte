#!/usr/bin/env python3
"""
FrostByte — auto-suspend inactive GUI apps to save RAM.
For GNOME on Wayland (Pop!_OS, Ubuntu, Fedora).

Monitors process CPU activity via /proc. After N minutes of inactivity,
sends SIGSTOP to freeze the process (and children). When the user focuses
the frozen window, the companion GNOME Shell extension writes the PID to
a temp file and the daemon instantly thaws it with SIGCONT.
"""

import os
import sys
import time
import signal
import json
import logging
import argparse
import curses
from pathlib import Path
from dataclasses import dataclass, field
from typing import Dict, Set, Optional, List

_UID = os.getuid()
FOCUS_FILE = Path(f"/tmp/frostbyte-focus-{_UID}")
STATUS_FILE = Path(f"/tmp/frostbyte-status-{_UID}.json")
THAW_FILE = Path(f"/tmp/frostbyte-thaw-{_UID}")
CONFIG_DIR = Path.home() / ".config" / "frostbyte"
CONFIG_FILE = CONFIG_DIR / "config.json"
LOG_FILE = CONFIG_DIR / "frostbyte.log"
PID_FILE = Path(f"/tmp/frostbyte-{_UID}.pid")

DEFAULT_CONFIG = {
    "freeze_after_minutes": 30,
    "min_rss_mb": 100,
    "poll_interval": 1,
    "scan_interval": 30,
    "whitelist": [
        "gnome-shell",
        "gnome-session",
        "gsd-",
        "mutter",
        "Xwayland",
        "pulseaudio",
        "pipewire",
        "wireplumber",
        "tilix",
        "gnome-terminal",
        "kitty",
        "alacritty",
        "wezterm",
        "bash",
        "zsh",
        "fish",
        "frostbyte",
        "docker",
        "containerd",
        "systemd",
        "dbus-daemon",
        "dbus-broker",
        "ssh",
        "sshd",
        "gpg-agent",
        "gnome-keyring",
    ],
}

PAGE_SIZE = os.sysconf("SC_PAGE_SIZE")


def _read_file(path: str) -> str:
    with open(path) as f:
        return f.read()


def _safe_addstr(win, y, x, text, attr=0):
    """Write text to curses window, silently ignoring out-of-bounds errors."""
    try:
        win.addstr(y, x, text, attr)
    except curses.error:
        pass


@dataclass
class Proc:
    pid: int
    name: str
    cmdline: str
    cpu: int
    rss_mb: float
    last_active: float
    frozen: bool = False


class FrostByteDaemon:
    def __init__(self, config_overrides: Optional[dict] = None):
        self.uid = os.getuid()
        self.procs: Dict[int, Proc] = {}
        self.frozen: Set[int] = set()
        self._ppid_map: Dict[int, List[int]] = {}
        self.config = self._load_config()
        if config_overrides:
            self.config.update(config_overrides)
        self._tick = 0

    # ── config ──────────────────────────────────────────────

    def _load_config(self) -> dict:
        cfg = DEFAULT_CONFIG.copy()
        if CONFIG_FILE.exists():
            try:
                cfg.update(json.loads(CONFIG_FILE.read_text()))
            except Exception as e:
                logging.warning(f"Bad config {CONFIG_FILE}: {e} — using defaults")
        return cfg

    def _save_default_config(self):
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        if not CONFIG_FILE.exists():
            CONFIG_FILE.write_text(json.dumps(DEFAULT_CONFIG, indent=2) + "\n")

    def _save_config(self):
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        CONFIG_FILE.write_text(json.dumps(self.config, indent=2) + "\n")

    def add_to_whitelist(self, name):
        existing = [p.lower() for p in self.config["whitelist"]]
        if name.lower() not in existing:
            self.config["whitelist"].append(name)
            self._save_config()
            return True
        return False

    # ── logging ─────────────────────────────────────────────

    def _setup_logging(self):
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        logging.basicConfig(
            level=logging.INFO,
            format="%(asctime)s %(message)s",
            datefmt="%H:%M:%S",
            handlers=[
                logging.FileHandler(LOG_FILE),
                logging.StreamHandler(sys.stdout),
            ],
        )

    # ── process scanning ────────────────────────────────────

    def _is_whitelisted(self, name: str, cmdline: str) -> bool:
        nl = name.lower()
        cl = cmdline.lower()
        for pat in self.config["whitelist"]:
            p = pat.lower()
            if p in nl or p in cl:
                return True
        return False

    def scan(self):
        """Read /proc and update internal process table."""
        now = time.time()
        seen: Set[int] = set()

        for entry in os.listdir("/proc"):
            if not entry.isdigit():
                continue
            pid = int(entry)
            try:
                raw = _read_file(f"/proc/{pid}/stat")
                lp = raw.index("(")
                rp = raw.rindex(")")
                comm = raw[lp + 1 : rp]
                f = raw[rp + 2 :].split()
                # f[0]=state f[1]=ppid f[2]=pgrp ... f[11]=utime f[12]=stime f[21]=rss
                state = f[0]

                status = _read_file(f"/proc/{pid}/status")
                if f"Uid:\t{self.uid}" not in status:
                    continue

                cpu = int(f[11]) + int(f[12])
                rss = int(f[21]) * PAGE_SIZE / 1048576

                try:
                    cmdline = (
                        _read_file(f"/proc/{pid}/cmdline").replace("\0", " ").strip()
                    )
                except Exception:
                    cmdline = comm

                seen.add(pid)

                if pid in self.procs:
                    p = self.procs[pid]
                    if cpu != p.cpu:
                        p.last_active = now
                    p.cpu = cpu
                    p.rss_mb = rss
                    # detect externally-resumed processes
                    if p.frozen and state != "T":
                        p.frozen = False
                        self.frozen.discard(pid)
                else:
                    self.procs[pid] = Proc(
                        pid=pid,
                        name=comm,
                        cmdline=cmdline,
                        cpu=cpu,
                        rss_mb=rss,
                        last_active=now,
                    )
            except (FileNotFoundError, ProcessLookupError, ValueError,
                    IndexError, PermissionError):
                continue

        self._ppid_map = {}
        for pid in seen:
            try:
                raw = _read_file(f"/proc/{pid}/stat")
                rp = raw.rindex(")")
                ppid = int(raw[rp + 2:].split()[1])
                self._ppid_map.setdefault(ppid, []).append(pid)
            except Exception:
                continue

        # purge dead
        for pid in set(self.procs) - seen:
            del self.procs[pid]
            self.frozen.discard(pid)

    # ── freeze / thaw ──────────────────────────────────────

    def _children(self, pid: int) -> List[int]:
        """Return list of all descendant PIDs."""
        kids = []
        for child in self._ppid_map.get(pid, []):
            kids.append(child)
            kids.extend(self._children(child))
        return kids

    def freeze_pid(self, pid: int, reason: str = ""):
        tree = [pid] + self._children(pid)
        count = 0
        for p in tree:
            try:
                os.kill(p, signal.SIGSTOP)
                self.frozen.add(p)
                if p in self.procs:
                    self.procs[p].frozen = True
                count += 1
            except (ProcessLookupError, PermissionError):
                pass
        if count:
            name = self.procs[pid].name if pid in self.procs else "?"
            rss = self.procs[pid].rss_mb if pid in self.procs else 0
            logging.info(
                f"FROZE  {name} pid={pid} ({count} procs, {rss:.0f}MB)"
                + (f" [{reason}]" if reason else "")
            )

    def thaw_pid(self, pid: int):
        # collect pid + all stopped children
        to_thaw: Set[int] = set()
        if self._is_stopped(pid):
            to_thaw.add(pid)
        for p in self._children(pid):
            if self._is_stopped(p):
                to_thaw.add(p)

        # also check parent — maybe it's the frozen root
        try:
            raw = _read_file(f"/proc/{pid}/stat")
            rp = raw.rindex(")")
            ppid = int(raw[rp + 2 :].split()[1])
            if self._is_stopped(ppid):
                to_thaw.add(ppid)
                for p in self._children(ppid):
                    if self._is_stopped(p):
                        to_thaw.add(p)
        except Exception:
            pass

        thawed = []
        for p in to_thaw:
            try:
                os.kill(p, signal.SIGCONT)
                self.frozen.discard(p)
                if p in self.procs:
                    self.procs[p].frozen = False
                    self.procs[p].last_active = time.time()
                thawed.append(p)
            except (ProcessLookupError, PermissionError):
                self.frozen.discard(p)

        if thawed:
            name = self.procs[pid].name if pid in self.procs else "?"
            logging.info(f"THAW   {name} pid={pid} ({len(thawed)} procs)")

    def thaw_all(self):
        self.scan()
        for pid in list(self.frozen):
            self.thaw_pid(pid)

    # ── focus tracking ──────────────────────────────────────

    def _is_stopped(self, pid: int) -> bool:
        """Check if a process is in T (stopped) state."""
        try:
            raw = _read_file(f"/proc/{pid}/stat")
            rp = raw.rindex(")")
            return raw[rp + 2 :].split()[0] == "T"
        except Exception:
            return False

    def _find_stopped_ancestor(self, pid: int) -> Optional[int]:
        """Walk up process tree to find a stopped (T) ancestor."""
        visited = set()
        current = pid
        while current > 1 and current not in visited:
            if self._is_stopped(current):
                return current
            visited.add(current)
            try:
                raw = _read_file(f"/proc/{current}/stat")
                rp = raw.rindex(")")
                current = int(raw[rp + 2 :].split()[1])
            except Exception:
                break
        return None

    def _check_focus(self):
        try:
            if FOCUS_FILE.exists():
                raw = FOCUS_FILE.read_text().strip()
                if raw:
                    pid = int(raw)
                    # check if this pid or any ancestor is actually stopped
                    stopped = self._find_stopped_ancestor(pid)
                    if stopped:
                        self.thaw_pid(stopped)
        except (ValueError, IOError):
            pass

    # ── freeze candidates ───────────────────────────────────

    def _check_freeze(self):
        now = time.time()
        threshold = self.config["freeze_after_minutes"] * 60
        min_rss = self.config["min_rss_mb"]

        for pid, p in list(self.procs.items()):
            if p.frozen:
                continue
            if self._is_whitelisted(p.name, p.cmdline):
                continue
            if p.rss_mb < min_rss:
                continue
            idle = now - p.last_active
            if idle >= threshold:
                self.freeze_pid(
                    pid,
                    reason=f"idle {idle / 60:.0f}min, {p.rss_mb:.0f}MB",
                )

    # ── status + thaw-request ────────────────────────────────

    def _write_status(self):
        frozen_list = []
        saved_mb = 0
        for pid in list(self.frozen):
            if pid in self.procs:
                p = self.procs[pid]
                frozen_list.append({"pid": pid, "name": p.name, "rss_mb": round(p.rss_mb)})
                saved_mb += p.rss_mb
        data = {"frozen": frozen_list, "saved_mb": round(saved_mb), "active": True}
        try:
            STATUS_FILE.write_text(json.dumps(data) + "\n")
        except Exception:
            pass

    def _check_thaw(self):
        try:
            if THAW_FILE.exists():
                raw = THAW_FILE.read_text().strip()
                THAW_FILE.unlink(missing_ok=True)
                if raw:
                    pid = int(raw)
                    self.thaw_pid(pid)
        except (ValueError, IOError):
            pass

    # ── shutdown ────────────────────────────────────────────

    def _shutdown(self, signum, frame):
        logging.info("Shutting down — thawing all frozen processes")
        for pid in list(self.frozen):
            try:
                os.kill(pid, signal.SIGCONT)
            except Exception:
                pass
        try:
            STATUS_FILE.write_text(json.dumps({"frozen": [], "saved_mb": 0, "active": False}) + "\n")
        except Exception:
            pass
        THAW_FILE.unlink(missing_ok=True)
        PID_FILE.unlink(missing_ok=True)
        sys.exit(0)

    def _check_already_running(self):
        if PID_FILE.exists():
            try:
                old_pid = int(PID_FILE.read_text().strip())
                os.kill(old_pid, 0)
                print(f"FrostByte already running (PID {old_pid})", file=sys.stderr)
                sys.exit(1)
            except (ProcessLookupError, ValueError):
                pass
            except PermissionError:
                print(f"FrostByte already running (PID {old_pid})", file=sys.stderr)
                sys.exit(1)

    # ── main loop ───────────────────────────────────────────

    def run(self):
        self._check_already_running()
        self._save_default_config()
        self._setup_logging()
        signal.signal(signal.SIGTERM, self._shutdown)
        signal.signal(signal.SIGINT, self._shutdown)

        PID_FILE.write_text(str(os.getpid()))

        cfg = self.config
        logging.info(
            f"FrostByte started — freeze after {cfg['freeze_after_minutes']}min, "
            f"min RSS {cfg['min_rss_mb']}MB, "
            f"poll {cfg['poll_interval']}s, scan {cfg['scan_interval']}s"
        )

        scans_per_tick = max(1, cfg["scan_interval"] // cfg["poll_interval"])

        while True:
            self._check_focus()
            self._check_thaw()

            self._tick += 1
            if self._tick >= scans_per_tick:
                self._tick = 0
                self.scan()
                self._check_freeze()
                self._write_status()

            time.sleep(cfg["poll_interval"])

    # ── CLI helpers ─────────────────────────────────────────

    def print_status(self):
        self.scan()
        now = time.time()
        threshold = self.config["freeze_after_minutes"]
        min_rss = self.config["min_rss_mb"]

        # find frozen (T state) user processes
        frozen_list = []
        candidates = []
        for pid, p in sorted(self.procs.items(), key=lambda x: -x[1].rss_mb):
            try:
                raw = _read_file(f"/proc/{pid}/stat")
                rp = raw.rindex(")")
                state = raw[rp + 2 :].split()[0]
            except Exception:
                state = "?"

            if state == "T":
                frozen_list.append((pid, p))
            elif (
                not self._is_whitelisted(p.name, p.cmdline) and p.rss_mb >= min_rss
            ):
                idle = (now - p.last_active) / 60
                candidates.append((pid, p, idle))

        print(
            f"\n  Config: freeze after {threshold}min idle, "
            f"min RSS {min_rss}MB"
        )
        print(f"  Whitelist: {len(self.config['whitelist'])} patterns\n")

        if frozen_list:
            print(f"  FROZEN ({len(frozen_list)}):")
            for pid, p in frozen_list:
                print(f"    {pid:>7}  {p.rss_mb:>6.0f} MB  {p.name}")
        else:
            print("  FROZEN: none")

        print()
        if candidates:
            print(f"  CANDIDATES ({len(candidates)}):")
            for pid, p, idle in sorted(candidates, key=lambda x: -x[2])[:20]:
                bar_len = min(20, int(idle / threshold * 20))
                bar = "#" * bar_len + "-" * (20 - bar_len)
                print(
                    f"    {pid:>7}  {p.rss_mb:>6.0f} MB  "
                    f"idle {idle:>5.1f}m [{bar}] {p.name}"
                )
        else:
            print("  CANDIDATES: none (nothing above threshold)")
        print()


def cmd_run(args):
    overrides = {}
    if args.freeze_after is not None:
        overrides["freeze_after_minutes"] = args.freeze_after
    if args.min_rss is not None:
        overrides["min_rss_mb"] = args.min_rss
    daemon = FrostByteDaemon(overrides)
    daemon.run()


def cmd_status(args):
    FrostByteDaemon().print_status()


def cmd_thaw(args):
    d = FrostByteDaemon()
    d.scan()

    if args.name:
        pattern = args.name.lower()
        found = False
        for pid, p in d.procs.items():
            try:
                raw = _read_file(f"/proc/{pid}/stat")
                rp = raw.rindex(")")
                state = raw[rp + 2 :].split()[0]
            except Exception:
                continue
            if state == "T" and pattern in p.name.lower():
                os.kill(pid, signal.SIGCONT)
                print(f"  Thawed {p.name} (PID {pid})")
                found = True
        if not found:
            print(f"  No frozen process matching '{args.name}'")
    else:
        count = 0
        for pid, p in d.procs.items():
            try:
                raw = _read_file(f"/proc/{pid}/stat")
                rp = raw.rindex(")")
                state = raw[rp + 2 :].split()[0]
            except Exception:
                continue
            if state == "T":
                try:
                    os.kill(pid, signal.SIGCONT)
                    count += 1
                except Exception:
                    pass
        print(f"  Thawed {count} processes")


def cmd_freeze(args):
    d = FrostByteDaemon()
    d.scan()
    pattern = args.name.lower()
    found = False
    for pid, p in sorted(d.procs.items(), key=lambda x: -x[1].rss_mb):
        if pattern in p.name.lower() and not d._is_whitelisted(p.name, p.cmdline):
            d.freeze_pid(pid, reason="manual")
            print(f"  Froze {p.name} (PID {pid}, {p.rss_mb:.0f}MB)")
            found = True
            break
    if not found:
        print(f"  No running process matching '{args.name}' (or it's whitelisted)")


_LOGO = [
    "  ╔═╗┬─┐┌─┐┌─┐┌┬┐╔╗ ┬ ┬┌┬┐┌─┐",
    "  ╠╣ ├┬┘│ │└─┐ │ ╠╩╗└┬┘ │ ├┤ ",
    "  ╚  ┴└─└─┘└─┘ ┴ ╚═╝ ┴  ┴ └─┘",
]

_LOGO_BIG = [" ".join(r) for r in zip(
    ["███████", "██     ", "█████  ", "██     ", "██     "],  # F
    ["██████ ", "██   ██", "██████ ", "██   ██", "██   ██"],  # R
    [" ██████ ", "██    ██", "██    ██", "██    ██", " ██████ "],  # O
    ["███████", "██     ", "███████", "     ██", "███████"],  # S
    ["████████", "   ██   ", "   ██   ", "   ██   ", "   ██   "],  # T
    ["██████ ", "██   ██", "██████ ", "██   ██", "██████ "],  # B
    ["██    ██", " ██  ██ ", "  ████  ", "   ██   ", "   ██   "],  # Y
    ["████████", "   ██   ", "   ██   ", "   ██   ", "   ██   "],  # T
    ["███████", "██     ", "█████  ", "██     ", "███████"],  # E
)]

_SNOW = "·  ❄  ·  ✦  ·  ❄  ·  ✦  ·  ❄  ·  ✦  ·  ❄  ·"


def _monitor_tui(stdscr):
    """Live curses dashboard — modern TUI with visual blocks."""
    curses.use_default_colors()
    curses.curs_set(0)
    stdscr.timeout(2000)
    _MOUSE_MOVE = getattr(curses, 'REPORT_MOUSE_POSITION', 0)
    curses.mousemask(curses.ALL_MOUSE_EVENTS | _MOUSE_MOVE)
    _B5 = getattr(curses, 'BUTTON5_PRESSED', curses.BUTTON4_PRESSED << 2)

    use_256 = curses.COLORS >= 256

    C_LOGO = 1; C_BORDER = 2; C_FROZEN = 3; C_CAND = 4
    C_STAT_VAL = 5; C_STAT_LBL = 6; C_BAR_FULL = 7; C_BAR_EMPTY = 8
    C_FOOTER = 9; C_FOOTER_KEY = 10; C_MSG = 11; C_SELECT = 12
    C_PROMPT = 13; C_HEAD = 14; C_DIM = 15; C_BAR_HOT = 16
    C_LOGO1 = 17; C_LOGO2 = 18; C_LOGO3 = 19; C_LOGO4 = 20; C_LOGO5 = 21
    C_BTN = 22; C_BTN_SKIP = 23

    if use_256:
        curses.init_pair(C_LOGO, 81, -1)
        curses.init_pair(C_BORDER, 239, -1)
        curses.init_pair(C_FROZEN, 75, -1)
        curses.init_pair(C_CAND, 222, -1)
        curses.init_pair(C_STAT_VAL, 114, -1)
        curses.init_pair(C_STAT_LBL, 245, -1)
        curses.init_pair(C_BAR_FULL, 75, -1)
        curses.init_pair(C_BAR_EMPTY, 238, -1)
        curses.init_pair(C_FOOTER, 252, 236)
        curses.init_pair(C_FOOTER_KEY, 81, 236)
        curses.init_pair(C_MSG, 222, -1)
        curses.init_pair(C_SELECT, 255, 237)
        curses.init_pair(C_PROMPT, 81, -1)
        curses.init_pair(C_HEAD, 252, -1)
        curses.init_pair(C_DIM, 242, -1)
        curses.init_pair(C_BAR_HOT, 203, -1)
        curses.init_pair(C_LOGO1, 159, -1)
        curses.init_pair(C_LOGO2, 123, -1)
        curses.init_pair(C_LOGO3, 87, -1)
        curses.init_pair(C_LOGO4, 81, -1)
        curses.init_pair(C_LOGO5, 75, -1)
        curses.init_pair(C_BTN, 81, 237)
        curses.init_pair(C_BTN_SKIP, 222, 237)
    else:
        curses.init_pair(C_LOGO, curses.COLOR_CYAN, -1)
        curses.init_pair(C_BORDER, curses.COLOR_WHITE, -1)
        curses.init_pair(C_FROZEN, curses.COLOR_BLUE, -1)
        curses.init_pair(C_CAND, curses.COLOR_YELLOW, -1)
        curses.init_pair(C_STAT_VAL, curses.COLOR_GREEN, -1)
        curses.init_pair(C_STAT_LBL, curses.COLOR_WHITE, -1)
        curses.init_pair(C_BAR_FULL, curses.COLOR_CYAN, -1)
        curses.init_pair(C_BAR_EMPTY, curses.COLOR_WHITE, -1)
        curses.init_pair(C_FOOTER, curses.COLOR_WHITE, curses.COLOR_BLACK)
        curses.init_pair(C_FOOTER_KEY, curses.COLOR_CYAN, curses.COLOR_BLACK)
        curses.init_pair(C_MSG, curses.COLOR_YELLOW, -1)
        curses.init_pair(C_SELECT, curses.COLOR_WHITE, curses.COLOR_BLUE)
        curses.init_pair(C_PROMPT, curses.COLOR_CYAN, -1)
        curses.init_pair(C_HEAD, curses.COLOR_WHITE, -1)
        curses.init_pair(C_DIM, curses.COLOR_WHITE, -1)
        curses.init_pair(C_BAR_HOT, curses.COLOR_RED, -1)
        for cp in (C_LOGO1, C_LOGO2, C_LOGO3, C_LOGO4, C_LOGO5):
            curses.init_pair(cp, curses.COLOR_CYAN, -1)
        curses.init_pair(C_BTN, curses.COLOR_CYAN, curses.COLOR_BLACK)
        curses.init_pair(C_BTN_SKIP, curses.COLOR_YELLOW, curses.COLOR_BLACK)

    _logo_grad = [C_LOGO1, C_LOGO2, C_LOGO3, C_LOGO4, C_LOGO5]

    bdr = curses.color_pair(C_BORDER)
    daemon = FrostByteDaemon()
    message = ""
    msg_time = 0.0
    tab = 0        # 0=frozen, 1=candidates
    sel = 0        # selected index in active tab
    scroll = 0     # scroll offset
    last_scan = 0.0
    _tab_row = -1
    _tab0_end = 0
    _tab1_start = 0
    _tab1_end = 0
    _block_y = []  # (y_start, y_end, index) for mouse click targets
    _btn_act = None   # (y, x_start, x_end) for action button
    _btn_skip = None  # (y, x_start, x_end) for skip button

    def _framed(row, content="", attr=0):
        w = cols - 2
        _safe_addstr(stdscr, row, 0, "│", bdr)
        _safe_addstr(stdscr, row, 1, content[:w].ljust(w), attr)
        _safe_addstr(stdscr, row, cols - 1, "│", bdr)

    def _hline(row, left, right):
        line = left + "─" * max(0, cols - 2) + right
        _safe_addstr(stdscr, row, 0, line[:cols], bdr)

    def _fmt_mb(mb):
        return f"{mb / 1024:.1f} GB" if mb >= 1024 else f"{mb:.0f} MB"

    while True:
        now_t = time.time()
        if now_t - last_scan >= 2.0:
            daemon.scan()
            last_scan = now_t
        rows, cols = stdscr.getmaxyx()
        stdscr.erase()
        _btn_act = None
        _btn_skip = None

        if rows < 14 or cols < 60:
            _safe_addstr(stdscr, rows // 2, max(0, cols // 2 - 10),
                         "Terminal too small", curses.color_pair(C_DIM))
            stdscr.refresh()
            key = stdscr.getch()
            if key in (ord("q"), 27):
                break
            continue

        now = time.time()
        threshold = daemon.config["freeze_after_minutes"]
        min_rss = daemon.config["min_rss_mb"]
        inner = cols - 2

        # ── collect data ──
        frozen_list = []
        candidates = []
        saved_mb = 0.0
        for pid, p in sorted(daemon.procs.items(), key=lambda x: -x[1].rss_mb):
            try:
                raw = _read_file(f"/proc/{pid}/stat")
                rp = raw.rindex(")")
                state = raw[rp + 2:].split()[0]
            except Exception:
                state = "?"
            if state == "T":
                frozen_list.append((pid, p))
                saved_mb += p.rss_mb
            elif not daemon._is_whitelisted(p.name, p.cmdline) and p.rss_mb >= min_rss:
                idle_min = (now - p.last_active) / 60
                candidates.append((pid, p, idle_min))
        candidates.sort(key=lambda x: -x[2])

        # ── group by process name ──
        fg = {}
        for pid, p in frozen_list:
            g = fg.setdefault(p.name, {"name": p.name, "pids": [], "total_rss": 0.0})
            g["pids"].append(pid)
            g["total_rss"] += p.rss_mb
        fg_list = sorted(fg.values(), key=lambda g: -g["total_rss"])

        cg = {}
        for pid, p, idle in candidates:
            g = cg.setdefault(p.name, {"name": p.name, "pids": [], "total_rss": 0.0, "max_idle": 0.0})
            g["pids"].append(pid)
            g["total_rss"] += p.rss_mb
            g["max_idle"] = max(g["max_idle"], idle)
        cg_list = sorted(cg.values(), key=lambda g: -g["max_idle"])

        items = fg_list if tab == 0 else cg_list
        if sel >= len(items):
            sel = max(0, len(items) - 1)

        r = 0

        # ── top border ──
        _hline(r, "╭", "╮"); r += 1

        # ── logo (adaptive: big with gradient or compact) ──
        use_big = inner >= 77 and rows >= 24
        logo = _LOGO_BIG if use_big else _LOGO
        logo_w = max(len(l) for l in logo)
        lx = max(1, (cols - logo_w) // 2)

        if use_big:
            # snowflake decoration line
            sx = max(1, (cols - len(_SNOW)) // 2)
            _safe_addstr(stdscr, r, 0, "│", bdr)
            _safe_addstr(stdscr, r, sx, _SNOW[:inner],
                         curses.color_pair(C_DIM))
            _safe_addstr(stdscr, r, cols - 1, "│", bdr)
            r += 1

        for i, line in enumerate(logo):
            _safe_addstr(stdscr, r + i, 0, "│", bdr)
            if use_big:
                lc = _logo_grad[i] if i < len(_logo_grad) else C_LOGO
            else:
                lc = C_LOGO
            _safe_addstr(stdscr, r + i, lx, line,
                         curses.color_pair(lc) | curses.A_BOLD)
            _safe_addstr(stdscr, r + i, cols - 1, "│", bdr)
        r += len(logo)

        if use_big:
            # snowflake decoration line
            _safe_addstr(stdscr, r, 0, "│", bdr)
            _safe_addstr(stdscr, r, sx, _SNOW[:inner],
                         curses.color_pair(C_DIM))
            _safe_addstr(stdscr, r, cols - 1, "│", bdr)
            r += 1
            # tagline centered below logo
            tagline = "❄  auto-freeze for idle apps  ❄"
            ttx = max(1, (cols - len(tagline)) // 2)
            _safe_addstr(stdscr, r, 0, "│", bdr)
            _safe_addstr(stdscr, r, ttx, tagline,
                         curses.color_pair(C_STAT_LBL))
            _safe_addstr(stdscr, r, cols - 1, "│", bdr)
            r += 1
        else:
            tagline = "auto-freeze for idle apps"
            tx = cols - 2 - len(tagline) - 1
            if tx > lx + logo_w + 2:
                _safe_addstr(stdscr, r - 1, tx, tagline,
                             curses.color_pair(C_STAT_LBL))

        _framed(r); r += 1

        # ── stats ribbon ──
        _safe_addstr(stdscr, r, 0, "│", bdr)
        cx = 3
        for label, val in [("RAM Saved", _fmt_mb(saved_mb)),
                           ("Frozen", str(len(frozen_list))),
                           ("Candidates", str(len(candidates)))]:
            if cx + len(label) + len(val) + 2 >= cols - 1:
                break
            _safe_addstr(stdscr, r, cx, label, curses.color_pair(C_STAT_LBL))
            _safe_addstr(stdscr, r, cx + len(label) + 1, val,
                         curses.color_pair(C_STAT_VAL) | curses.A_BOLD)
            cx += len(label) + len(val) + 5
        _safe_addstr(stdscr, r, cols - 1, "│", bdr)
        r += 1

        _framed(r); r += 1

        # ── tab bar ──
        tab0 = f" ❄ Frozen ({len(frozen_list)}) "
        tab1 = f" ◐ Candidates ({len(candidates)}) "
        _safe_addstr(stdscr, r, 0, "│", bdr)
        t0x = 3
        if tab == 0:
            _safe_addstr(stdscr, r, t0x, tab0,
                         curses.color_pair(C_LOGO) | curses.A_BOLD | curses.A_UNDERLINE)
        else:
            _safe_addstr(stdscr, r, t0x, tab0, curses.color_pair(C_DIM))
        t1x = t0x + len(tab0) + 3
        _tab_row = r
        _tab0_end = t0x + len(tab0)
        _tab1_start = t1x
        _tab1_end = t1x + len(tab1)
        if tab == 1:
            _safe_addstr(stdscr, r, t1x, tab1,
                         curses.color_pair(C_CAND) | curses.A_BOLD | curses.A_UNDERLINE)
        else:
            _safe_addstr(stdscr, r, t1x, tab1, curses.color_pair(C_DIM))
        _safe_addstr(stdscr, r, cols - 1, "│", bdr)
        r += 1

        # ── content divider ──
        _hline(r, "├", "┤"); r += 1

        # ── content area (blocks) ──
        content_top = r
        content_bot = rows - 3  # reserve: message + bottom border + footer
        content_h = content_bot - content_top
        BLOCK_H = 3  # name line + bar line + blank separator

        if content_h < 2 or not items:
            _block_y = []
            mid = content_top + content_h // 2
            empty = "No frozen processes" if tab == 0 else "No candidates"
            for rr in range(content_top, content_bot):
                if rr == mid:
                    _framed(rr, f"   {empty}", curses.color_pair(C_DIM))
                else:
                    _framed(rr)
        else:
            max_vis = max(1, (content_h + 1) // BLOCK_H)

            # scroll management
            if sel < scroll:
                scroll = sel
            if sel >= scroll + max_vis:
                scroll = sel - max_vis + 1
            scroll = max(0, min(scroll, len(items) - max_vis))

            visible = items[scroll:scroll + max_vis]
            max_rss = max(g["total_rss"] for g in items)
            bar_w = max(8, inner - 6)  # full-width bar

            _block_y = []
            rr = content_top
            for vi, group in enumerate(visible):
                if rr + 1 >= content_bot:
                    break
                idx = scroll + vi
                _blk_y0 = rr
                is_sel = (idx == sel)
                name = group["name"]
                rss_str = _fmt_mb(group["total_rss"])

                if tab == 0:
                    n = len(group["pids"])
                    right = f"{rss_str}   {n} proc{'s' if n != 1 else ''}"
                else:
                    idle = group["max_idle"]
                    right = f"{rss_str}   idle {idle:.1f}m"

                left = f" ▸ {name}" if is_sel else f"   {name}"
                gap = inner - len(left) - len(right) - 1
                if gap < 1:
                    gap = 1

                # ── name line ──
                _safe_addstr(stdscr, rr, 0, "│", bdr)
                if is_sel:
                    btn_lbl = " Thaw " if tab == 0 else " Freeze "
                    skip_lbl = " Skip "
                    skip_x = cols - 1 - len(skip_lbl)
                    act_x = skip_x - 1 - len(btn_lbl)
                    _safe_addstr(stdscr, rr, 1, " " * inner,
                                 curses.color_pair(C_SELECT))
                    _safe_addstr(stdscr, rr, 1, left[:inner],
                                 curses.color_pair(C_SELECT) | curses.A_BOLD)
                    rx = 1 + len(left) + gap
                    right_end = act_x - 1
                    if rx + len(right) <= right_end:
                        _safe_addstr(stdscr, rr, rx, right,
                                     curses.color_pair(C_SELECT))
                    _safe_addstr(stdscr, rr, act_x, btn_lbl,
                                 curses.color_pair(C_BTN) | curses.A_BOLD)
                    _safe_addstr(stdscr, rr, skip_x, skip_lbl,
                                 curses.color_pair(C_BTN_SKIP) | curses.A_BOLD)
                    _btn_act = (rr, act_x, act_x + len(btn_lbl))
                    _btn_skip = (rr, skip_x, skip_x + len(skip_lbl))
                else:
                    rc = C_FROZEN if tab == 0 else C_CAND
                    _safe_addstr(stdscr, rr, 1, left[:inner],
                                 curses.color_pair(rc))
                    rx = 1 + len(left) + gap
                    if rx + len(right) < cols - 1:
                        _safe_addstr(stdscr, rr, rx, right,
                                     curses.color_pair(C_HEAD))
                _safe_addstr(stdscr, rr, cols - 1, "│", bdr)
                rr += 1

                # ── bar line (full-width) ──
                if rr < content_bot:
                    _safe_addstr(stdscr, rr, 0, "│", bdr)
                    bx = 4
                    if tab == 0:
                        filled = int(group["total_rss"] / max_rss * bar_w) if max_rss > 0 else 0
                        filled = max(1, min(bar_w, filled))
                        for j in range(min(bar_w, cols - bx - 1)):
                            if j < filled:
                                _safe_addstr(stdscr, rr, bx + j, "█",
                                             curses.color_pair(C_BAR_FULL))
                            else:
                                _safe_addstr(stdscr, rr, bx + j, "░",
                                             curses.color_pair(C_BAR_EMPTY))
                    else:
                        pct = group["max_idle"] / threshold if threshold > 0 else 0
                        filled = max(0, min(bar_w, int(pct * bar_w)))
                        for j in range(min(bar_w, cols - bx - 1)):
                            if j < filled:
                                pos_pct = (j + 1) / bar_w
                                if pos_pct > 0.8:
                                    c = C_BAR_HOT
                                elif pos_pct > 0.5:
                                    c = C_CAND
                                else:
                                    c = C_BAR_FULL
                                _safe_addstr(stdscr, rr, bx + j, "█",
                                             curses.color_pair(c))
                            else:
                                _safe_addstr(stdscr, rr, bx + j, "░",
                                             curses.color_pair(C_BAR_EMPTY))
                    _safe_addstr(stdscr, rr, cols - 1, "│", bdr)
                    rr += 1

                # ── separator ──
                if rr < content_bot and vi < len(visible) - 1:
                    _framed(rr)
                    rr += 1
                _block_y.append((_blk_y0, rr, idx))

            # fill remaining
            while rr < content_bot:
                _framed(rr)
                rr += 1

            # scroll indicators
            if scroll > 0:
                _safe_addstr(stdscr, content_top, cols - 2, "▲",
                             curses.color_pair(C_DIM))
            if scroll + max_vis < len(items):
                _safe_addstr(stdscr, content_bot - 1, cols - 2, "▼",
                             curses.color_pair(C_DIM))

        r = content_bot

        # ── message ──
        if message and now - msg_time > 5:
            message = ""
        _framed(r, f"  {message}" if message else "", curses.color_pair(C_MSG))
        r += 1

        # ── bottom border ──
        _hline(r, "╰", "╯"); r += 1

        # ── footer ──
        _safe_addstr(stdscr, rows - 1, 0, " " * cols, curses.color_pair(C_FOOTER))
        keys = [("q", "quit"), ("⏎/click", "thaw/freeze"), ("↑↓/scroll", "select"),
                ("tab", "switch"), ("f", "freeze"), ("t", "thaw"), ("e", "exclude")]
        fx = 1
        for k, d in keys:
            if fx >= cols - 4:
                break
            _safe_addstr(stdscr, rows - 1, fx, f" {k} ",
                         curses.color_pair(C_FOOTER_KEY) | curses.A_BOLD)
            fx += len(k) + 2
            _safe_addstr(stdscr, rows - 1, fx, f"{d}  ",
                         curses.color_pair(C_FOOTER))
            fx += len(d) + 2

        stdscr.refresh()

        # ── input ──
        key = stdscr.getch()
        perform_action = False
        do_skip = False

        if key in (ord("q"), 27):
            break
        elif key == ord("r"):
            message = ""
        elif key == curses.KEY_RESIZE:
            pass
        elif key == ord("\t") or key == curses.KEY_BTAB:
            tab = 1 - tab
            sel = 0
            scroll = 0
        elif key == curses.KEY_UP:
            sel = max(0, sel - 1)
        elif key == curses.KEY_DOWN:
            sel = min(len(items) - 1, sel + 1) if items else 0
        elif key == curses.KEY_PPAGE:
            sel = max(0, sel - 5)
        elif key == curses.KEY_NPAGE:
            sel = min(len(items) - 1, sel + 5) if items else 0
        elif key in (ord("\n"), 10, 13):
            perform_action = True
        elif key == curses.KEY_MOUSE:
            try:
                _, mx, my, _, bstate = curses.getmouse()
                if bstate & curses.BUTTON4_PRESSED:
                    sel = max(0, sel - 1)
                elif bstate & _B5:
                    sel = min(len(items) - 1, sel + 1) if items else 0
                elif bstate & curses.BUTTON1_DOUBLE_CLICKED:
                    if my == _tab_row:
                        if 3 <= mx < _tab0_end:
                            tab = 0; sel = 0; scroll = 0
                        elif _tab1_start <= mx < _tab1_end:
                            tab = 1; sel = 0; scroll = 0
                    else:
                        for y0, y1, bi in _block_y:
                            if y0 <= my < y1:
                                sel = bi
                                perform_action = True
                                break
                elif bstate & (curses.BUTTON1_PRESSED | curses.BUTTON1_CLICKED):
                    if my == _tab_row:
                        if 3 <= mx < _tab0_end:
                            tab = 0; sel = 0; scroll = 0
                        elif _tab1_start <= mx < _tab1_end:
                            tab = 1; sel = 0; scroll = 0
                    elif _btn_act and my == _btn_act[0] and _btn_act[1] <= mx < _btn_act[2]:
                        perform_action = True
                    elif _btn_skip and my == _btn_skip[0] and _btn_skip[1] <= mx < _btn_skip[2]:
                        do_skip = True
                    else:
                        for y0, y1, bi in _block_y:
                            if y0 <= my < y1:
                                if bi == sel:
                                    perform_action = True
                                else:
                                    sel = bi
                                break
                else:
                    # hover — select block under cursor
                    for y0, y1, bi in _block_y:
                        if y0 <= my < y1:
                            sel = bi
                            break
            except curses.error:
                pass
        elif key == ord("e"):
            if items and 0 <= sel < len(items):
                do_skip = True
        elif key in (ord("f"), ord("t")):
            action = "freeze" if key == ord("f") else "thaw"
            curses.curs_set(1)
            curses.mousemask(0)
            prompt = f"  {action} ▸ "
            mr = rows - 3
            _safe_addstr(stdscr, mr, 0, "│", bdr)
            _safe_addstr(stdscr, mr, 1, " " * (cols - 2), 0)
            _safe_addstr(stdscr, mr, 1, prompt,
                         curses.color_pair(C_PROMPT) | curses.A_BOLD)
            _safe_addstr(stdscr, mr, cols - 1, "│", bdr)
            stdscr.refresh()
            curses.echo()
            try:
                nb = stdscr.getstr(mr, 1 + len(prompt), 40)
            except curses.error:
                nb = b""
            curses.noecho()
            curses.curs_set(0)
            curses.mousemask(curses.ALL_MOUSE_EVENTS | _MOUSE_MOVE)
            ni = nb.decode("utf-8", errors="replace").strip().lower()
            if ni:
                if action == "freeze":
                    match = None
                    for pid, p in sorted(daemon.procs.items(), key=lambda x: -x[1].rss_mb):
                        if ni in p.name.lower() and not daemon._is_whitelisted(p.name, p.cmdline):
                            match = (pid, p)
                            break
                    if match:
                        pid, p = match
                        daemon.freeze_pid(pid, reason="monitor")
                        message = f"❄ Froze {p.name} (PID {pid})"
                    else:
                        message = f"✗ No match: {ni}"
                else:
                    match = None
                    for pid, p in daemon.procs.items():
                        if ni in p.name.lower() and daemon._is_stopped(pid):
                            match = (pid, p)
                            break
                    if match:
                        pid, p = match
                        daemon.thaw_pid(pid)
                        message = f"✓ Thawed {p.name} (PID {pid})"
                    else:
                        message = f"✗ No frozen match: {ni}"
                msg_time = now
            else:
                message = ""

        if perform_action and items and 0 <= sel < len(items):
            group = items[sel]
            if tab == 0:
                for pid in group["pids"]:
                    daemon.thaw_pid(pid)
                n = len(group["pids"])
                message = f"✓ Thawed {group['name']} ({n} proc{'s' if n != 1 else ''})"
            else:
                for pid in group["pids"]:
                    daemon.freeze_pid(pid, reason="monitor")
                n = len(group["pids"])
                message = f"❄ Froze {group['name']} ({n} proc{'s' if n != 1 else ''})"
            msg_time = now

        if do_skip and items and 0 <= sel < len(items):
            group = items[sel]
            if daemon.add_to_whitelist(group["name"]):
                message = f"⊘ Excluded '{group['name']}' from freezing"
            else:
                message = f"  '{group['name']}' already excluded"
            msg_time = now


def cmd_monitor(args):
    curses.wrapper(_monitor_tui)


def main():
    parser = argparse.ArgumentParser(
        prog="frostbyte",
        description="Auto-suspend inactive apps to save RAM",
    )
    sub = parser.add_subparsers(dest="cmd")

    p_run = sub.add_parser("run", help="Start the daemon (foreground)")
    p_run.add_argument("--freeze-after", type=int, dest="freeze_after")
    p_run.add_argument("--min-rss", type=int, dest="min_rss")
    p_run.set_defaults(func=cmd_run)

    p_status = sub.add_parser("status", help="Show frozen & candidate processes")
    p_status.set_defaults(func=cmd_status)

    p_thaw = sub.add_parser("thaw", help="Thaw frozen processes")
    p_thaw.add_argument("name", nargs="?", help="Process name pattern (or all)")
    p_thaw.set_defaults(func=cmd_thaw)

    p_freeze = sub.add_parser("freeze", help="Manually freeze a process")
    p_freeze.add_argument("name", help="Process name pattern")
    p_freeze.set_defaults(func=cmd_freeze)

    p_monitor = sub.add_parser("monitor", help="Live TUI dashboard")
    p_monitor.set_defaults(func=cmd_monitor)

    args = parser.parse_args()
    if not args.cmd:
        parser.print_help()
        return
    args.func(args)


if __name__ == "__main__":
    main()
