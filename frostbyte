#!/usr/bin/env python3
"""
FrostByte — auto-suspend inactive GUI apps to save RAM.
For GNOME on Wayland (Pop!_OS, Ubuntu, Fedora).

Monitors process CPU activity via /proc. After N minutes of inactivity,
sends SIGSTOP to freeze the process (and children). When the user focuses
the frozen window, the companion GNOME Shell extension writes the PID to
a temp file and the daemon instantly thaws it with SIGCONT.
"""

import os
import sys
import time
import signal
import json
import logging
import argparse
import curses
from pathlib import Path
from dataclasses import dataclass, field
from typing import Dict, Set, Optional, List

_UID = os.getuid()
FOCUS_FILE = Path(f"/tmp/frostbyte-focus-{_UID}")
STATUS_FILE = Path(f"/tmp/frostbyte-status-{_UID}.json")
THAW_FILE = Path(f"/tmp/frostbyte-thaw-{_UID}")
CONFIG_DIR = Path.home() / ".config" / "frostbyte"
CONFIG_FILE = CONFIG_DIR / "config.json"
LOG_FILE = CONFIG_DIR / "frostbyte.log"
PID_FILE = Path(f"/tmp/frostbyte-{_UID}.pid")

DEFAULT_CONFIG = {
    "freeze_after_minutes": 30,
    "min_rss_mb": 100,
    "poll_interval": 1,
    "scan_interval": 30,
    "whitelist": [
        "gnome-shell",
        "gnome-session",
        "gsd-",
        "mutter",
        "Xwayland",
        "pulseaudio",
        "pipewire",
        "wireplumber",
        "tilix",
        "gnome-terminal",
        "kitty",
        "alacritty",
        "wezterm",
        "bash",
        "zsh",
        "fish",
        "frostbyte",
        "docker",
        "containerd",
        "systemd",
        "dbus-daemon",
        "dbus-broker",
        "ssh",
        "sshd",
        "gpg-agent",
        "gnome-keyring",
    ],
}

PAGE_SIZE = os.sysconf("SC_PAGE_SIZE")


def _read_file(path: str) -> str:
    with open(path) as f:
        return f.read()


def _safe_addstr(win, y, x, text, attr=0):
    """Write text to curses window, silently ignoring out-of-bounds errors."""
    try:
        win.addstr(y, x, text, attr)
    except curses.error:
        pass


@dataclass
class Proc:
    pid: int
    name: str
    cmdline: str
    cpu: int
    rss_mb: float
    last_active: float
    frozen: bool = False


class FrostByteDaemon:
    def __init__(self, config_overrides: Optional[dict] = None):
        self.uid = os.getuid()
        self.procs: Dict[int, Proc] = {}
        self.frozen: Set[int] = set()
        self._ppid_map: Dict[int, List[int]] = {}
        self.config = self._load_config()
        if config_overrides:
            self.config.update(config_overrides)
        self._tick = 0

    # ── config ──────────────────────────────────────────────

    def _load_config(self) -> dict:
        cfg = DEFAULT_CONFIG.copy()
        if CONFIG_FILE.exists():
            try:
                cfg.update(json.loads(CONFIG_FILE.read_text()))
            except Exception as e:
                logging.warning(f"Bad config {CONFIG_FILE}: {e} — using defaults")
        return cfg

    def _save_default_config(self):
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        if not CONFIG_FILE.exists():
            CONFIG_FILE.write_text(json.dumps(DEFAULT_CONFIG, indent=2) + "\n")

    # ── logging ─────────────────────────────────────────────

    def _setup_logging(self):
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        logging.basicConfig(
            level=logging.INFO,
            format="%(asctime)s %(message)s",
            datefmt="%H:%M:%S",
            handlers=[
                logging.FileHandler(LOG_FILE),
                logging.StreamHandler(sys.stdout),
            ],
        )

    # ── process scanning ────────────────────────────────────

    def _is_whitelisted(self, name: str, cmdline: str) -> bool:
        nl = name.lower()
        cl = cmdline.lower()
        for pat in self.config["whitelist"]:
            p = pat.lower()
            if p in nl or p in cl:
                return True
        return False

    def scan(self):
        """Read /proc and update internal process table."""
        now = time.time()
        seen: Set[int] = set()

        for entry in os.listdir("/proc"):
            if not entry.isdigit():
                continue
            pid = int(entry)
            try:
                raw = _read_file(f"/proc/{pid}/stat")
                lp = raw.index("(")
                rp = raw.rindex(")")
                comm = raw[lp + 1 : rp]
                f = raw[rp + 2 :].split()
                # f[0]=state f[1]=ppid f[2]=pgrp ... f[11]=utime f[12]=stime f[21]=rss
                state = f[0]

                status = _read_file(f"/proc/{pid}/status")
                if f"Uid:\t{self.uid}" not in status:
                    continue

                cpu = int(f[11]) + int(f[12])
                rss = int(f[21]) * PAGE_SIZE / 1048576

                try:
                    cmdline = (
                        _read_file(f"/proc/{pid}/cmdline").replace("\0", " ").strip()
                    )
                except Exception:
                    cmdline = comm

                seen.add(pid)

                if pid in self.procs:
                    p = self.procs[pid]
                    if cpu != p.cpu:
                        p.last_active = now
                    p.cpu = cpu
                    p.rss_mb = rss
                    # detect externally-resumed processes
                    if p.frozen and state != "T":
                        p.frozen = False
                        self.frozen.discard(pid)
                else:
                    self.procs[pid] = Proc(
                        pid=pid,
                        name=comm,
                        cmdline=cmdline,
                        cpu=cpu,
                        rss_mb=rss,
                        last_active=now,
                    )
            except (FileNotFoundError, ProcessLookupError, ValueError,
                    IndexError, PermissionError):
                continue

        self._ppid_map = {}
        for pid in seen:
            try:
                raw = _read_file(f"/proc/{pid}/stat")
                rp = raw.rindex(")")
                ppid = int(raw[rp + 2:].split()[1])
                self._ppid_map.setdefault(ppid, []).append(pid)
            except Exception:
                continue

        # purge dead
        for pid in set(self.procs) - seen:
            del self.procs[pid]
            self.frozen.discard(pid)

    # ── freeze / thaw ──────────────────────────────────────

    def _children(self, pid: int) -> List[int]:
        """Return list of all descendant PIDs."""
        kids = []
        for child in self._ppid_map.get(pid, []):
            kids.append(child)
            kids.extend(self._children(child))
        return kids

    def freeze_pid(self, pid: int, reason: str = ""):
        tree = [pid] + self._children(pid)
        count = 0
        for p in tree:
            try:
                os.kill(p, signal.SIGSTOP)
                self.frozen.add(p)
                if p in self.procs:
                    self.procs[p].frozen = True
                count += 1
            except (ProcessLookupError, PermissionError):
                pass
        if count:
            name = self.procs[pid].name if pid in self.procs else "?"
            rss = self.procs[pid].rss_mb if pid in self.procs else 0
            logging.info(
                f"FROZE  {name} pid={pid} ({count} procs, {rss:.0f}MB)"
                + (f" [{reason}]" if reason else "")
            )

    def thaw_pid(self, pid: int):
        # collect pid + all stopped children
        to_thaw: Set[int] = set()
        if self._is_stopped(pid):
            to_thaw.add(pid)
        for p in self._children(pid):
            if self._is_stopped(p):
                to_thaw.add(p)

        # also check parent — maybe it's the frozen root
        try:
            raw = _read_file(f"/proc/{pid}/stat")
            rp = raw.rindex(")")
            ppid = int(raw[rp + 2 :].split()[1])
            if self._is_stopped(ppid):
                to_thaw.add(ppid)
                for p in self._children(ppid):
                    if self._is_stopped(p):
                        to_thaw.add(p)
        except Exception:
            pass

        thawed = []
        for p in to_thaw:
            try:
                os.kill(p, signal.SIGCONT)
                self.frozen.discard(p)
                if p in self.procs:
                    self.procs[p].frozen = False
                    self.procs[p].last_active = time.time()
                thawed.append(p)
            except (ProcessLookupError, PermissionError):
                self.frozen.discard(p)

        if thawed:
            name = self.procs[pid].name if pid in self.procs else "?"
            logging.info(f"THAW   {name} pid={pid} ({len(thawed)} procs)")

    def thaw_all(self):
        self.scan()
        for pid in list(self.frozen):
            self.thaw_pid(pid)

    # ── focus tracking ──────────────────────────────────────

    def _is_stopped(self, pid: int) -> bool:
        """Check if a process is in T (stopped) state."""
        try:
            raw = _read_file(f"/proc/{pid}/stat")
            rp = raw.rindex(")")
            return raw[rp + 2 :].split()[0] == "T"
        except Exception:
            return False

    def _find_stopped_ancestor(self, pid: int) -> Optional[int]:
        """Walk up process tree to find a stopped (T) ancestor."""
        visited = set()
        current = pid
        while current > 1 and current not in visited:
            if self._is_stopped(current):
                return current
            visited.add(current)
            try:
                raw = _read_file(f"/proc/{current}/stat")
                rp = raw.rindex(")")
                current = int(raw[rp + 2 :].split()[1])
            except Exception:
                break
        return None

    def _check_focus(self):
        try:
            if FOCUS_FILE.exists():
                raw = FOCUS_FILE.read_text().strip()
                if raw:
                    pid = int(raw)
                    # check if this pid or any ancestor is actually stopped
                    stopped = self._find_stopped_ancestor(pid)
                    if stopped:
                        self.thaw_pid(stopped)
        except (ValueError, IOError):
            pass

    # ── freeze candidates ───────────────────────────────────

    def _check_freeze(self):
        now = time.time()
        threshold = self.config["freeze_after_minutes"] * 60
        min_rss = self.config["min_rss_mb"]

        for pid, p in list(self.procs.items()):
            if p.frozen:
                continue
            if self._is_whitelisted(p.name, p.cmdline):
                continue
            if p.rss_mb < min_rss:
                continue
            idle = now - p.last_active
            if idle >= threshold:
                self.freeze_pid(
                    pid,
                    reason=f"idle {idle / 60:.0f}min, {p.rss_mb:.0f}MB",
                )

    # ── status + thaw-request ────────────────────────────────

    def _write_status(self):
        frozen_list = []
        saved_mb = 0
        for pid in list(self.frozen):
            if pid in self.procs:
                p = self.procs[pid]
                frozen_list.append({"pid": pid, "name": p.name, "rss_mb": round(p.rss_mb)})
                saved_mb += p.rss_mb
        data = {"frozen": frozen_list, "saved_mb": round(saved_mb), "active": True}
        try:
            STATUS_FILE.write_text(json.dumps(data) + "\n")
        except Exception:
            pass

    def _check_thaw(self):
        try:
            if THAW_FILE.exists():
                raw = THAW_FILE.read_text().strip()
                THAW_FILE.unlink(missing_ok=True)
                if raw:
                    pid = int(raw)
                    self.thaw_pid(pid)
        except (ValueError, IOError):
            pass

    # ── shutdown ────────────────────────────────────────────

    def _shutdown(self, signum, frame):
        logging.info("Shutting down — thawing all frozen processes")
        for pid in list(self.frozen):
            try:
                os.kill(pid, signal.SIGCONT)
            except Exception:
                pass
        try:
            STATUS_FILE.write_text(json.dumps({"frozen": [], "saved_mb": 0, "active": False}) + "\n")
        except Exception:
            pass
        THAW_FILE.unlink(missing_ok=True)
        PID_FILE.unlink(missing_ok=True)
        sys.exit(0)

    def _check_already_running(self):
        if PID_FILE.exists():
            try:
                old_pid = int(PID_FILE.read_text().strip())
                os.kill(old_pid, 0)
                print(f"FrostByte already running (PID {old_pid})", file=sys.stderr)
                sys.exit(1)
            except (ProcessLookupError, ValueError):
                pass
            except PermissionError:
                print(f"FrostByte already running (PID {old_pid})", file=sys.stderr)
                sys.exit(1)

    # ── main loop ───────────────────────────────────────────

    def run(self):
        self._check_already_running()
        self._save_default_config()
        self._setup_logging()
        signal.signal(signal.SIGTERM, self._shutdown)
        signal.signal(signal.SIGINT, self._shutdown)

        PID_FILE.write_text(str(os.getpid()))

        cfg = self.config
        logging.info(
            f"FrostByte started — freeze after {cfg['freeze_after_minutes']}min, "
            f"min RSS {cfg['min_rss_mb']}MB, "
            f"poll {cfg['poll_interval']}s, scan {cfg['scan_interval']}s"
        )

        scans_per_tick = max(1, cfg["scan_interval"] // cfg["poll_interval"])

        while True:
            self._check_focus()
            self._check_thaw()

            self._tick += 1
            if self._tick >= scans_per_tick:
                self._tick = 0
                self.scan()
                self._check_freeze()
                self._write_status()

            time.sleep(cfg["poll_interval"])

    # ── CLI helpers ─────────────────────────────────────────

    def print_status(self):
        self.scan()
        now = time.time()
        threshold = self.config["freeze_after_minutes"]
        min_rss = self.config["min_rss_mb"]

        # find frozen (T state) user processes
        frozen_list = []
        candidates = []
        for pid, p in sorted(self.procs.items(), key=lambda x: -x[1].rss_mb):
            try:
                raw = _read_file(f"/proc/{pid}/stat")
                rp = raw.rindex(")")
                state = raw[rp + 2 :].split()[0]
            except Exception:
                state = "?"

            if state == "T":
                frozen_list.append((pid, p))
            elif (
                not self._is_whitelisted(p.name, p.cmdline) and p.rss_mb >= min_rss
            ):
                idle = (now - p.last_active) / 60
                candidates.append((pid, p, idle))

        print(
            f"\n  Config: freeze after {threshold}min idle, "
            f"min RSS {min_rss}MB"
        )
        print(f"  Whitelist: {len(self.config['whitelist'])} patterns\n")

        if frozen_list:
            print(f"  FROZEN ({len(frozen_list)}):")
            for pid, p in frozen_list:
                print(f"    {pid:>7}  {p.rss_mb:>6.0f} MB  {p.name}")
        else:
            print("  FROZEN: none")

        print()
        if candidates:
            print(f"  CANDIDATES ({len(candidates)}):")
            for pid, p, idle in sorted(candidates, key=lambda x: -x[2])[:20]:
                bar_len = min(20, int(idle / threshold * 20))
                bar = "#" * bar_len + "-" * (20 - bar_len)
                print(
                    f"    {pid:>7}  {p.rss_mb:>6.0f} MB  "
                    f"idle {idle:>5.1f}m [{bar}] {p.name}"
                )
        else:
            print("  CANDIDATES: none (nothing above threshold)")
        print()


def cmd_run(args):
    overrides = {}
    if args.freeze_after is not None:
        overrides["freeze_after_minutes"] = args.freeze_after
    if args.min_rss is not None:
        overrides["min_rss_mb"] = args.min_rss
    daemon = FrostByteDaemon(overrides)
    daemon.run()


def cmd_status(args):
    FrostByteDaemon().print_status()


def cmd_thaw(args):
    d = FrostByteDaemon()
    d.scan()

    if args.name:
        pattern = args.name.lower()
        found = False
        for pid, p in d.procs.items():
            try:
                raw = _read_file(f"/proc/{pid}/stat")
                rp = raw.rindex(")")
                state = raw[rp + 2 :].split()[0]
            except Exception:
                continue
            if state == "T" and pattern in p.name.lower():
                os.kill(pid, signal.SIGCONT)
                print(f"  Thawed {p.name} (PID {pid})")
                found = True
        if not found:
            print(f"  No frozen process matching '{args.name}'")
    else:
        count = 0
        for pid, p in d.procs.items():
            try:
                raw = _read_file(f"/proc/{pid}/stat")
                rp = raw.rindex(")")
                state = raw[rp + 2 :].split()[0]
            except Exception:
                continue
            if state == "T":
                try:
                    os.kill(pid, signal.SIGCONT)
                    count += 1
                except Exception:
                    pass
        print(f"  Thawed {count} processes")


def cmd_freeze(args):
    d = FrostByteDaemon()
    d.scan()
    pattern = args.name.lower()
    found = False
    for pid, p in sorted(d.procs.items(), key=lambda x: -x[1].rss_mb):
        if pattern in p.name.lower() and not d._is_whitelisted(p.name, p.cmdline):
            d.freeze_pid(pid, reason="manual")
            print(f"  Froze {p.name} (PID {pid}, {p.rss_mb:.0f}MB)")
            found = True
            break
    if not found:
        print(f"  No running process matching '{args.name}' (or it's whitelisted)")


_LOGO = [
    "  ╔═╗┬─┐┌─┐┌─┐┌┬┐╔╗ ┬ ┬┌┬┐┌─┐",
    "  ╠╣ ├┬┘│ │└─┐ │ ╠╩╗└┬┘ │ ├┤ ",
    "  ╚  ┴└─└─┘└─┘ ┴ ╚═╝ ┴  ┴ └─┘",
]


def _monitor_tui(stdscr):
    """Live curses dashboard — modern TUI."""
    curses.use_default_colors()
    curses.curs_set(0)
    stdscr.timeout(2000)

    # 256-color support check
    use_256 = curses.COLORS >= 256

    # color pairs — semantic
    C_LOGO = 1       # bright cyan for logo
    C_BORDER = 2     # dim border
    C_FROZEN = 3     # blue for frozen rows
    C_CAND = 4       # yellow for candidates
    C_STAT_VAL = 5   # green for stat values
    C_STAT_LBL = 6   # dim for stat labels
    C_BAR_FULL = 7   # bar filled portion
    C_BAR_EMPTY = 8  # bar empty portion
    C_FOOTER = 9     # footer bar
    C_FOOTER_KEY = 10  # footer key highlights
    C_MSG = 11       # status messages
    C_SELECT = 12    # selected row
    C_PROMPT = 13    # input prompt
    C_HEAD = 14      # section headers
    C_DIM = 15       # dimmed text
    C_BAR_HOT = 16   # bar nearly full (red/orange)

    if use_256:
        curses.init_pair(C_LOGO, 81, -1)       # bright sky blue
        curses.init_pair(C_BORDER, 239, -1)     # dark gray
        curses.init_pair(C_FROZEN, 75, -1)      # steel blue
        curses.init_pair(C_CAND, 222, -1)       # warm yellow
        curses.init_pair(C_STAT_VAL, 114, -1)   # soft green
        curses.init_pair(C_STAT_LBL, 245, -1)   # medium gray
        curses.init_pair(C_BAR_FULL, 75, -1)    # blue bar
        curses.init_pair(C_BAR_EMPTY, 238, -1)  # very dark gray
        curses.init_pair(C_FOOTER, 252, 236)    # light on dark
        curses.init_pair(C_FOOTER_KEY, 81, 236) # cyan keys on dark
        curses.init_pair(C_MSG, 222, -1)        # yellow messages
        curses.init_pair(C_SELECT, 255, 237)    # white on subtle bg
        curses.init_pair(C_PROMPT, 81, -1)      # cyan prompt
        curses.init_pair(C_HEAD, 252, -1)       # bright white
        curses.init_pair(C_DIM, 242, -1)        # dim gray
        curses.init_pair(C_BAR_HOT, 203, -1)    # red/orange for >80%
    else:
        curses.init_pair(C_LOGO, curses.COLOR_CYAN, -1)
        curses.init_pair(C_BORDER, curses.COLOR_WHITE, -1)
        curses.init_pair(C_FROZEN, curses.COLOR_BLUE, -1)
        curses.init_pair(C_CAND, curses.COLOR_YELLOW, -1)
        curses.init_pair(C_STAT_VAL, curses.COLOR_GREEN, -1)
        curses.init_pair(C_STAT_LBL, curses.COLOR_WHITE, -1)
        curses.init_pair(C_BAR_FULL, curses.COLOR_CYAN, -1)
        curses.init_pair(C_BAR_EMPTY, curses.COLOR_WHITE, -1)
        curses.init_pair(C_FOOTER, curses.COLOR_WHITE, curses.COLOR_BLACK)
        curses.init_pair(C_FOOTER_KEY, curses.COLOR_CYAN, curses.COLOR_BLACK)
        curses.init_pair(C_MSG, curses.COLOR_YELLOW, -1)
        curses.init_pair(C_SELECT, curses.COLOR_WHITE, curses.COLOR_BLUE)
        curses.init_pair(C_PROMPT, curses.COLOR_CYAN, -1)
        curses.init_pair(C_HEAD, curses.COLOR_WHITE, -1)
        curses.init_pair(C_DIM, curses.COLOR_WHITE, -1)
        curses.init_pair(C_BAR_HOT, curses.COLOR_RED, -1)

    daemon = FrostByteDaemon()
    message = ""
    msg_time = 0
    selected = 0       # index in the flat item list
    scroll = 0         # scroll offset

    def _draw_hline(row, left, right, mid_char="─"):
        line = left + mid_char * max(0, cols - 2) + right
        _safe_addstr(stdscr, row, 0, line[:cols], curses.color_pair(C_BORDER))

    def _draw_row(row, text, attr, is_selected=False):
        if is_selected:
            line = ("  ▸ " + text)[:cols].ljust(cols)
            _safe_addstr(stdscr, row, 0, line, curses.color_pair(C_SELECT) | curses.A_BOLD)
        else:
            line = ("    " + text)[:cols]
            _safe_addstr(stdscr, row, 0, line, attr)

    while True:
        daemon.scan()
        rows, cols = stdscr.getmaxyx()
        stdscr.erase()

        if rows < 12 or cols < 50:
            _safe_addstr(stdscr, rows // 2, max(0, cols // 2 - 12),
                         "Terminal too small", curses.color_pair(C_DIM))
            _safe_addstr(stdscr, rows // 2 + 1, max(0, cols // 2 - 12),
                         "Need at least 50x12", curses.color_pair(C_DIM))
            stdscr.refresh()
            key = stdscr.getch()
            if key == ord("q"):
                break
            continue

        # ── data ──
        now = time.time()
        threshold = daemon.config["freeze_after_minutes"]
        min_rss = daemon.config["min_rss_mb"]

        frozen_list = []
        candidates = []
        saved_mb = 0
        for pid, p in sorted(daemon.procs.items(), key=lambda x: -x[1].rss_mb):
            try:
                raw = _read_file(f"/proc/{pid}/stat")
                rp = raw.rindex(")")
                state = raw[rp + 2:].split()[0]
            except Exception:
                state = "?"
            if state == "T":
                frozen_list.append((pid, p))
                saved_mb += p.rss_mb
            elif not daemon._is_whitelisted(p.name, p.cmdline) and p.rss_mb >= min_rss:
                idle = (now - p.last_active) / 60
                candidates.append((pid, p, idle))
        candidates.sort(key=lambda x: -x[2])

        # build flat item list for selection: ("frozen", pid, proc) or ("cand", pid, proc, idle)
        items = []
        for pid, p in frozen_list:
            items.append(("frozen", pid, p, 0))
        for pid, p, idle in candidates:
            items.append(("cand", pid, p, idle))

        if selected >= len(items):
            selected = max(0, len(items) - 1)

        row = 0

        # ── logo ──
        logo_width = max(len(l) for l in _LOGO)
        logo_x = max(0, (cols - logo_width) // 2)
        for i, line in enumerate(_LOGO):
            _safe_addstr(stdscr, row + i, logo_x, line,
                         curses.color_pair(C_LOGO) | curses.A_BOLD)
        row += len(_LOGO) + 1

        # ── stats cards ──
        def _fmt_mb(mb):
            if mb >= 1024:
                return f"{mb / 1024:.1f} GB"
            return f"{mb:.0f} MB"

        saved_str = _fmt_mb(saved_mb)
        cards = [
            ("RAM saved", saved_str),
            ("Frozen", str(len(frozen_list))),
            ("Candidates", str(len(candidates))),
            ("Threshold", f"{threshold}m / {min_rss}MB"),
        ]
        card_x = 2
        for label, value in cards:
            _safe_addstr(stdscr, row, card_x, label,
                         curses.color_pair(C_STAT_LBL) | curses.A_DIM)
            _safe_addstr(stdscr, row, card_x + len(label) + 1, value,
                         curses.color_pair(C_STAT_VAL) | curses.A_BOLD)
            card_x += len(label) + len(value) + 5
        row += 2

        # ── frozen section ──
        sec_label = f" ❄ Frozen ({len(frozen_list)}) "
        _draw_hline(row, "╭", "╮")
        _safe_addstr(stdscr, row, 2, sec_label,
                     curses.color_pair(C_LOGO) | curses.A_BOLD)
        row += 1

        # column headers
        hdr = f"{'PID':>7}  {'RSS':>8}  {'Name'}"
        _safe_addstr(stdscr, row, 4, hdr[:cols - 4],
                     curses.color_pair(C_DIM) | curses.A_DIM)
        row += 1

        if frozen_list:
            visible_area = rows - row - 8  # leave room for candidates + footer
            frozen_area = min(len(frozen_list), max(3, visible_area // 2))
            for i, (pid, p) in enumerate(frozen_list[:frozen_area]):
                text = f"{pid:>7}  {p.rss_mb:>6.0f} MB  {p.name}"
                is_sel = (i == selected)
                _draw_row(row, text, curses.color_pair(C_FROZEN), is_sel)
                row += 1
            if len(frozen_list) > frozen_area:
                more = len(frozen_list) - frozen_area
                _safe_addstr(stdscr, row, 4, f"… +{more} more",
                             curses.color_pair(C_DIM) | curses.A_DIM)
                row += 1
        else:
            _safe_addstr(stdscr, row, 4, "No frozen processes",
                         curses.color_pair(C_DIM) | curses.A_DIM)
            row += 1

        _draw_hline(row, "╰", "╯")
        row += 2

        # ── candidates section ──
        if row < rows - 5:
            sec_label = f" ◐ Candidates ({len(candidates)}) "
            _draw_hline(row, "╭", "╮")
            _safe_addstr(stdscr, row, 2, sec_label,
                         curses.color_pair(C_CAND) | curses.A_BOLD)
            row += 1

            hdr = f"{'PID':>7}  {'RSS':>8}  {'Idle':>6}  {'Progress':>17}  {'Name'}"
            _safe_addstr(stdscr, row, 4, hdr[:cols - 4],
                         curses.color_pair(C_DIM) | curses.A_DIM)
            row += 1

            bar_w = min(15, max(8, cols - 55))
            if candidates:
                cand_area = rows - row - 4
                sel_offset = len(frozen_list)
                for i, (pid, p, idle) in enumerate(candidates[:cand_area]):
                    if row >= rows - 3:
                        break
                    filled = min(bar_w, int(idle / threshold * bar_w))
                    pct = idle / threshold
                    bar_chr = "█" * filled + "░" * (bar_w - filled)
                    text = f"{pid:>7}  {p.rss_mb:>6.0f} MB  {idle:>5.1f}m "
                    is_sel = (sel_offset + i == selected)

                    if is_sel:
                        line = ("  ▸ " + text)[:cols].ljust(cols)
                        _safe_addstr(stdscr, row, 0, line,
                                     curses.color_pair(C_SELECT) | curses.A_BOLD)
                        bar_x = len("  ▸ " + text)
                    else:
                        _safe_addstr(stdscr, row, 4, text, curses.color_pair(C_CAND))
                        bar_x = 4 + len(text)

                    # draw bar with color based on fill percentage
                    _safe_addstr(stdscr, row, bar_x, "[", curses.color_pair(C_DIM))
                    for j in range(bar_w):
                        if j < filled:
                            if pct > 0.8:
                                c = C_BAR_HOT
                            else:
                                c = C_BAR_FULL
                            _safe_addstr(stdscr, row, bar_x + 1 + j, "█",
                                         curses.color_pair(c))
                        else:
                            _safe_addstr(stdscr, row, bar_x + 1 + j, "░",
                                         curses.color_pair(C_BAR_EMPTY))
                    _safe_addstr(stdscr, row, bar_x + 1 + bar_w, "]",
                                 curses.color_pair(C_DIM))
                    # process name after bar
                    name_x = bar_x + bar_w + 3
                    name_attr = curses.color_pair(C_SELECT) | curses.A_BOLD if is_sel else curses.color_pair(C_HEAD)
                    _safe_addstr(stdscr, row, name_x, p.name[:cols - name_x],
                                 name_attr)
                    row += 1

                if len(candidates) > cand_area:
                    more = len(candidates) - cand_area
                    _safe_addstr(stdscr, row, 4, f"… +{more} more",
                                 curses.color_pair(C_DIM) | curses.A_DIM)
                    row += 1
            else:
                _safe_addstr(stdscr, row, 4, "No candidates above threshold",
                             curses.color_pair(C_DIM) | curses.A_DIM)
                row += 1

            if row < rows - 2:
                _draw_hline(row, "╰", "╯")

        # ── footer ──
        # status message (auto-clear after 5s)
        if message and now - msg_time > 5:
            message = ""
        if message:
            _safe_addstr(stdscr, rows - 2, 2, message[:cols - 2],
                         curses.color_pair(C_MSG))

        # keybinding bar
        keys = [("q", "quit"), ("r", "refresh"), ("f", "freeze"),
                ("t", "thaw"), ("↑↓", "select"), ("enter", "action")]
        footer_x = 1
        _safe_addstr(stdscr, rows - 1, 0, " " * cols, curses.color_pair(C_FOOTER))
        for key_str, desc in keys:
            if footer_x >= cols - 4:
                break
            _safe_addstr(stdscr, rows - 1, footer_x, f" {key_str} ",
                         curses.color_pair(C_FOOTER_KEY) | curses.A_BOLD)
            footer_x += len(key_str) + 2
            _safe_addstr(stdscr, rows - 1, footer_x, f"{desc}  ",
                         curses.color_pair(C_FOOTER))
            footer_x += len(desc) + 2

        stdscr.refresh()

        # ── input ──
        key = stdscr.getch()
        if key == ord("q") or key == 27:  # q or Esc
            break
        elif key == ord("r"):
            message = ""
        elif key == curses.KEY_RESIZE:
            pass
        elif key == curses.KEY_UP:
            selected = max(0, selected - 1)
        elif key == curses.KEY_DOWN:
            selected = min(len(items) - 1, selected + 1) if items else 0
        elif key in (ord("\n"), 10, 13):  # Enter — toggle freeze/thaw on selected
            if items and 0 <= selected < len(items):
                kind, sel_pid, sel_p, _ = items[selected]
                if kind == "frozen":
                    daemon.thaw_pid(sel_pid)
                    message = f"  ✓ Thawed {sel_p.name} (PID {sel_pid})"
                else:
                    daemon.freeze_pid(sel_pid, reason="monitor")
                    message = f"  ❄ Froze {sel_p.name} (PID {sel_pid})"
                msg_time = now
        elif key in (ord("f"), ord("t")):
            action = "freeze" if key == ord("f") else "thaw"
            curses.curs_set(1)
            prompt_text = f"  {action} ▸ "
            _safe_addstr(stdscr, rows - 2, 0, " " * cols, 0)
            _safe_addstr(stdscr, rows - 2, 0, prompt_text,
                         curses.color_pair(C_PROMPT) | curses.A_BOLD)
            stdscr.refresh()
            curses.echo()
            try:
                name_bytes = stdscr.getstr(rows - 2, len(prompt_text), 40)
            except curses.error:
                name_bytes = b""
            curses.noecho()
            curses.curs_set(0)
            name_input = name_bytes.decode("utf-8", errors="replace").strip().lower()

            if name_input:
                if action == "freeze":
                    match = None
                    for pid, p in sorted(daemon.procs.items(), key=lambda x: -x[1].rss_mb):
                        if name_input in p.name.lower() and not daemon._is_whitelisted(p.name, p.cmdline):
                            match = (pid, p)
                            break
                    if match:
                        pid, p = match
                        daemon.freeze_pid(pid, reason="monitor")
                        message = f"  ❄ Froze {p.name} (PID {pid})"
                    else:
                        message = f"  ✗ No match: {name_input}"
                else:
                    match = None
                    for pid, p in daemon.procs.items():
                        if name_input in p.name.lower() and daemon._is_stopped(pid):
                            match = (pid, p)
                            break
                    if match:
                        pid, p = match
                        daemon.thaw_pid(pid)
                        message = f"  ✓ Thawed {p.name} (PID {pid})"
                    else:
                        message = f"  ✗ No frozen match: {name_input}"
                msg_time = now
            else:
                message = ""


def cmd_monitor(args):
    curses.wrapper(_monitor_tui)


def main():
    parser = argparse.ArgumentParser(
        prog="frostbyte",
        description="Auto-suspend inactive apps to save RAM",
    )
    sub = parser.add_subparsers(dest="cmd")

    p_run = sub.add_parser("run", help="Start the daemon (foreground)")
    p_run.add_argument("--freeze-after", type=int, dest="freeze_after")
    p_run.add_argument("--min-rss", type=int, dest="min_rss")
    p_run.set_defaults(func=cmd_run)

    p_status = sub.add_parser("status", help="Show frozen & candidate processes")
    p_status.set_defaults(func=cmd_status)

    p_thaw = sub.add_parser("thaw", help="Thaw frozen processes")
    p_thaw.add_argument("name", nargs="?", help="Process name pattern (or all)")
    p_thaw.set_defaults(func=cmd_thaw)

    p_freeze = sub.add_parser("freeze", help="Manually freeze a process")
    p_freeze.add_argument("name", help="Process name pattern")
    p_freeze.set_defaults(func=cmd_freeze)

    p_monitor = sub.add_parser("monitor", help="Live TUI dashboard")
    p_monitor.set_defaults(func=cmd_monitor)

    args = parser.parse_args()
    if not args.cmd:
        parser.print_help()
        return
    args.func(args)


if __name__ == "__main__":
    main()
