#!/usr/bin/env python3
"""
FrostByte — auto-suspend inactive GUI apps to save RAM.
For GNOME on Wayland (Pop!_OS, Ubuntu, Fedora).

Monitors process CPU activity via /proc. After N minutes of inactivity,
sends SIGSTOP to freeze the process (and children). When the user focuses
the frozen window, the companion GNOME Shell extension writes the PID to
a temp file and the daemon instantly thaws it with SIGCONT.
"""

import os
import sys
import time
import signal
import json
import logging
import argparse
import curses
import math
from pathlib import Path
from dataclasses import dataclass, field
from typing import Dict, Set, Optional, List

_UID = os.getuid()
FOCUS_FILE = Path(f"/tmp/frostbyte-focus-{_UID}")
STATUS_FILE = Path(f"/tmp/frostbyte-status-{_UID}.json")
THAW_FILE = Path(f"/tmp/frostbyte-thaw-{_UID}")
CONFIG_DIR = Path.home() / ".config" / "frostbyte"
CONFIG_FILE = CONFIG_DIR / "config.json"
LOG_FILE = CONFIG_DIR / "frostbyte.log"
PID_FILE = Path(f"/tmp/frostbyte-{_UID}.pid")

DEFAULT_CONFIG = {
    "freeze_after_minutes": 30,
    "min_rss_mb": 100,
    "poll_interval": 1,
    "scan_interval": 30,
    "max_freeze_hours": 4,
    "whitelist": [
        "gnome-shell",
        "gnome-session",
        "gsd-",
        "mutter",
        "Xwayland",
        "pulseaudio",
        "pipewire",
        "wireplumber",
        "tilix",
        "gnome-terminal",
        "kitty",
        "alacritty",
        "wezterm",
        "bash",
        "zsh",
        "fish",
        "frostbyte",
        "docker",
        "containerd",
        "systemd",
        "dbus-daemon",
        "dbus-broker",
        "ssh",
        "sshd",
        "gpg-agent",
        "gnome-keyring",
    ],
}

PAGE_SIZE = os.sysconf("SC_PAGE_SIZE")


def _read_file(path: str) -> str:
    with open(path) as f:
        return f.read()


def _safe_addstr(win, y, x, text, attr=0):
    """Write text to curses window, silently ignoring out-of-bounds errors."""
    try:
        win.addstr(y, x, text, attr)
    except curses.error:
        pass


@dataclass
class Proc:
    pid: int
    name: str
    cmdline: str
    cpu: int
    rss_mb: float
    last_active: float
    frozen: bool = False


class FrostByteDaemon:
    def __init__(self, config_overrides: Optional[dict] = None):
        self.uid = os.getuid()
        self.procs: Dict[int, Proc] = {}
        self.frozen: Set[int] = set()
        self._frozen_at: Dict[int, float] = {}
        self._ppid_map: Dict[int, List[int]] = {}
        self.config = self._load_config()
        if config_overrides:
            self.config.update(config_overrides)
        self._tick = 0

    # ── config ──────────────────────────────────────────────

    def _load_config(self) -> dict:
        cfg = DEFAULT_CONFIG.copy()
        if CONFIG_FILE.exists():
            try:
                cfg.update(json.loads(CONFIG_FILE.read_text()))
            except Exception as e:
                logging.warning(f"Bad config {CONFIG_FILE}: {e} — using defaults")
        return cfg

    def _save_default_config(self):
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        if not CONFIG_FILE.exists():
            CONFIG_FILE.write_text(json.dumps(DEFAULT_CONFIG, indent=2) + "\n")

    def _save_config(self):
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        CONFIG_FILE.write_text(json.dumps(self.config, indent=2) + "\n")

    def add_to_whitelist(self, name):
        existing = [p.lower() for p in self.config["whitelist"]]
        if name.lower() not in existing:
            self.config["whitelist"].append(name)
            self._save_config()
            return True
        return False

    def remove_from_whitelist(self, name):
        try:
            self.config["whitelist"].remove(name)
            self._save_config()
            return True
        except ValueError:
            return False

    # ── logging ─────────────────────────────────────────────

    def _setup_logging(self):
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        logging.basicConfig(
            level=logging.INFO,
            format="%(asctime)s %(message)s",
            datefmt="%H:%M:%S",
            handlers=[
                logging.FileHandler(LOG_FILE),
                logging.StreamHandler(sys.stdout),
            ],
        )

    # ── process scanning ────────────────────────────────────

    def _is_whitelisted(self, name: str, cmdline: str) -> bool:
        nl = name.lower()
        cl = cmdline.lower()
        for pat in self.config["whitelist"]:
            p = pat.lower()
            if p in nl or p in cl:
                return True
        return False

    def scan(self):
        """Read /proc and update internal process table."""
        now = time.time()
        seen: Set[int] = set()

        for entry in os.listdir("/proc"):
            if not entry.isdigit():
                continue
            pid = int(entry)
            try:
                raw = _read_file(f"/proc/{pid}/stat")
                lp = raw.index("(")
                rp = raw.rindex(")")
                comm = raw[lp + 1 : rp]
                f = raw[rp + 2 :].split()
                # f[0]=state f[1]=ppid f[2]=pgrp ... f[11]=utime f[12]=stime f[21]=rss
                state = f[0]

                status = _read_file(f"/proc/{pid}/status")
                if f"Uid:\t{self.uid}" not in status:
                    continue

                cpu = int(f[11]) + int(f[12])
                rss = int(f[21]) * PAGE_SIZE / 1048576

                try:
                    cmdline = (
                        _read_file(f"/proc/{pid}/cmdline").replace("\0", " ").strip()
                    )
                except Exception:
                    cmdline = comm

                seen.add(pid)

                if pid in self.procs:
                    p = self.procs[pid]
                    if cpu != p.cpu:
                        p.last_active = now
                    p.cpu = cpu
                    p.rss_mb = rss
                    # detect externally-resumed processes
                    if p.frozen and state != "T":
                        p.frozen = False
                        self.frozen.discard(pid)
                else:
                    self.procs[pid] = Proc(
                        pid=pid,
                        name=comm,
                        cmdline=cmdline,
                        cpu=cpu,
                        rss_mb=rss,
                        last_active=now,
                    )
            except (FileNotFoundError, ProcessLookupError, ValueError,
                    IndexError, PermissionError):
                continue

        self._ppid_map = {}
        for pid in seen:
            try:
                raw = _read_file(f"/proc/{pid}/stat")
                rp = raw.rindex(")")
                ppid = int(raw[rp + 2:].split()[1])
                self._ppid_map.setdefault(ppid, []).append(pid)
            except Exception:
                continue

        # purge dead
        for pid in set(self.procs) - seen:
            del self.procs[pid]
            self.frozen.discard(pid)
            self._frozen_at.pop(pid, None)

    # ── freeze / thaw ──────────────────────────────────────

    def _children(self, pid: int) -> List[int]:
        """Return list of all descendant PIDs."""
        kids = []
        for child in self._ppid_map.get(pid, []):
            kids.append(child)
            kids.extend(self._children(child))
        return kids

    def freeze_pid(self, pid: int, reason: str = ""):
        tree = [pid] + self._children(pid)
        count = 0
        for p in tree:
            try:
                os.kill(p, signal.SIGSTOP)
                self.frozen.add(p)
                self._frozen_at.setdefault(p, time.time())
                if p in self.procs:
                    self.procs[p].frozen = True
                count += 1
            except (ProcessLookupError, PermissionError):
                pass
        if count:
            name = self.procs[pid].name if pid in self.procs else "?"
            rss = self.procs[pid].rss_mb if pid in self.procs else 0
            logging.info(
                f"FROZE  {name} pid={pid} ({count} procs, {rss:.0f}MB)"
                + (f" [{reason}]" if reason else "")
            )

    def thaw_pid(self, pid: int):
        # collect pid + all stopped children
        to_thaw: Set[int] = set()
        if self._is_stopped(pid):
            to_thaw.add(pid)
        for p in self._children(pid):
            if self._is_stopped(p):
                to_thaw.add(p)

        # also check parent — maybe it's the frozen root
        try:
            raw = _read_file(f"/proc/{pid}/stat")
            rp = raw.rindex(")")
            ppid = int(raw[rp + 2 :].split()[1])
            if self._is_stopped(ppid):
                to_thaw.add(ppid)
                for p in self._children(ppid):
                    if self._is_stopped(p):
                        to_thaw.add(p)
        except Exception:
            pass

        # children first: leaves thaw before roots, delay before root
        sorted_pids = sorted(to_thaw, key=lambda p: len(self._children(p)))
        thawed = []
        for i, p in enumerate(sorted_pids):
            # pause before the root process so children are schedulable
            if i == len(sorted_pids) - 1 and len(thawed) > 0:
                time.sleep(0.05)
            try:
                os.kill(p, signal.SIGCONT)
                self.frozen.discard(p)
                self._frozen_at.pop(p, None)
                if p in self.procs:
                    self.procs[p].frozen = False
                    self.procs[p].last_active = time.time()
                thawed.append(p)
            except (ProcessLookupError, PermissionError):
                self.frozen.discard(p)
                self._frozen_at.pop(p, None)

        if thawed:
            name = self.procs[pid].name if pid in self.procs else "?"
            logging.info(f"THAW   {name} pid={pid} ({len(thawed)} procs)")

    def thaw_all(self):
        self.scan()
        for pid in list(self.frozen):
            self.thaw_pid(pid)

    # ── focus tracking ──────────────────────────────────────

    def _is_stopped(self, pid: int) -> bool:
        """Check if a process is in T (stopped) state."""
        try:
            raw = _read_file(f"/proc/{pid}/stat")
            rp = raw.rindex(")")
            return raw[rp + 2 :].split()[0] == "T"
        except Exception:
            return False

    def _find_stopped_ancestor(self, pid: int) -> Optional[int]:
        """Walk up process tree to find a stopped (T) ancestor."""
        visited = set()
        current = pid
        while current > 1 and current not in visited:
            if self._is_stopped(current):
                return current
            visited.add(current)
            try:
                raw = _read_file(f"/proc/{current}/stat")
                rp = raw.rindex(")")
                current = int(raw[rp + 2 :].split()[1])
            except Exception:
                break
        return None

    def _check_focus(self):
        try:
            if FOCUS_FILE.exists():
                raw = FOCUS_FILE.read_text().strip()
                if raw:
                    pid = int(raw)
                    # check if this pid or any ancestor is actually stopped
                    stopped = self._find_stopped_ancestor(pid)
                    if stopped:
                        self.thaw_pid(stopped)
        except (ValueError, IOError):
            pass

    # ── auto-thaw (max freeze duration) ────────────────────

    def _check_auto_thaw(self):
        max_h = self.config.get("max_freeze_hours", 0)
        if max_h <= 0:
            return
        max_secs = max_h * 3600
        now = time.time()
        for pid in list(self.frozen):
            frozen_since = self._frozen_at.get(pid, now)
            if now - frozen_since >= max_secs:
                name = self.procs[pid].name if pid in self.procs else "?"
                logging.info(
                    f"AUTO-THAW {name} pid={pid} "
                    f"(frozen {(now - frozen_since) / 3600:.1f}h, limit={max_h}h)"
                )
                self.thaw_pid(pid)

    # ── freeze candidates ───────────────────────────────────

    def _check_freeze(self):
        now = time.time()
        threshold = self.config["freeze_after_minutes"] * 60
        min_rss = self.config["min_rss_mb"]

        for pid, p in list(self.procs.items()):
            if p.frozen:
                continue
            if self._is_whitelisted(p.name, p.cmdline):
                continue
            if p.rss_mb < min_rss:
                continue
            idle = now - p.last_active
            if idle >= threshold:
                self.freeze_pid(
                    pid,
                    reason=f"idle {idle / 60:.0f}min, {p.rss_mb:.0f}MB",
                )

    # ── status + thaw-request ────────────────────────────────

    def _write_status(self):
        frozen_list = []
        saved_mb = 0
        for pid in list(self.frozen):
            if pid in self.procs:
                p = self.procs[pid]
                frozen_list.append({"pid": pid, "name": p.name, "rss_mb": round(p.rss_mb)})
                saved_mb += p.rss_mb
        data = {"frozen": frozen_list, "saved_mb": round(saved_mb), "active": True}
        try:
            STATUS_FILE.write_text(json.dumps(data) + "\n")
        except Exception:
            pass

    def _check_thaw(self):
        try:
            if THAW_FILE.exists():
                raw = THAW_FILE.read_text().strip()
                THAW_FILE.unlink(missing_ok=True)
                if raw:
                    pid = int(raw)
                    self.thaw_pid(pid)
        except (ValueError, IOError):
            pass

    # ── shutdown ────────────────────────────────────────────

    def _shutdown(self, signum, frame):
        logging.info("Shutting down — thawing all frozen processes")
        for pid in list(self.frozen):
            try:
                os.kill(pid, signal.SIGCONT)
            except Exception:
                pass
        try:
            STATUS_FILE.write_text(json.dumps({"frozen": [], "saved_mb": 0, "active": False}) + "\n")
        except Exception:
            pass
        THAW_FILE.unlink(missing_ok=True)
        PID_FILE.unlink(missing_ok=True)
        sys.exit(0)

    def _check_already_running(self):
        if PID_FILE.exists():
            try:
                old_pid = int(PID_FILE.read_text().strip())
                os.kill(old_pid, 0)
                print(f"FrostByte already running (PID {old_pid})", file=sys.stderr)
                sys.exit(1)
            except (ProcessLookupError, ValueError):
                pass
            except PermissionError:
                print(f"FrostByte already running (PID {old_pid})", file=sys.stderr)
                sys.exit(1)

    # ── main loop ───────────────────────────────────────────

    def run(self):
        self._check_already_running()
        self._save_default_config()
        self._setup_logging()
        signal.signal(signal.SIGTERM, self._shutdown)
        signal.signal(signal.SIGINT, self._shutdown)

        PID_FILE.write_text(str(os.getpid()))

        cfg = self.config
        logging.info(
            f"FrostByte started — freeze after {cfg['freeze_after_minutes']}min, "
            f"min RSS {cfg['min_rss_mb']}MB, "
            f"poll {cfg['poll_interval']}s, scan {cfg['scan_interval']}s"
        )

        scans_per_tick = max(1, cfg["scan_interval"] // cfg["poll_interval"])

        while True:
            self._check_focus()
            self._check_thaw()

            self._tick += 1
            if self._tick >= scans_per_tick:
                self._tick = 0
                self.scan()
                self._check_freeze()
                self._check_auto_thaw()
                self._write_status()

            time.sleep(cfg["poll_interval"])

    # ── CLI helpers ─────────────────────────────────────────

    def print_status(self):
        self.scan()
        now = time.time()
        threshold = self.config["freeze_after_minutes"]
        min_rss = self.config["min_rss_mb"]

        # find frozen (T state) user processes
        frozen_list = []
        candidates = []
        for pid, p in sorted(self.procs.items(), key=lambda x: -x[1].rss_mb):
            try:
                raw = _read_file(f"/proc/{pid}/stat")
                rp = raw.rindex(")")
                state = raw[rp + 2 :].split()[0]
            except Exception:
                state = "?"

            if state == "T":
                frozen_list.append((pid, p))
            elif (
                not self._is_whitelisted(p.name, p.cmdline) and p.rss_mb >= min_rss
            ):
                idle = (now - p.last_active) / 60
                candidates.append((pid, p, idle))

        print(
            f"\n  Config: freeze after {threshold}min idle, "
            f"min RSS {min_rss}MB"
        )
        print(f"  Whitelist: {len(self.config['whitelist'])} patterns\n")

        if frozen_list:
            print(f"  FROZEN ({len(frozen_list)}):")
            for pid, p in frozen_list:
                print(f"    {pid:>7}  {p.rss_mb:>6.0f} MB  {p.name}")
        else:
            print("  FROZEN: none")

        print()
        if candidates:
            print(f"  CANDIDATES ({len(candidates)}):")
            for pid, p, idle in sorted(candidates, key=lambda x: -x[2])[:20]:
                bar_len = min(20, int(idle / threshold * 20))
                bar = "#" * bar_len + "-" * (20 - bar_len)
                print(
                    f"    {pid:>7}  {p.rss_mb:>6.0f} MB  "
                    f"idle {idle:>5.1f}m [{bar}] {p.name}"
                )
        else:
            print("  CANDIDATES: none (nothing above threshold)")
        print()


def cmd_run(args):
    overrides = {}
    if args.freeze_after is not None:
        overrides["freeze_after_minutes"] = args.freeze_after
    if args.min_rss is not None:
        overrides["min_rss_mb"] = args.min_rss
    daemon = FrostByteDaemon(overrides)
    daemon.run()


def cmd_status(args):
    FrostByteDaemon().print_status()


def cmd_thaw(args):
    d = FrostByteDaemon()
    d.scan()

    if args.name:
        pattern = args.name.lower()
        found = False
        for pid, p in d.procs.items():
            try:
                raw = _read_file(f"/proc/{pid}/stat")
                rp = raw.rindex(")")
                state = raw[rp + 2 :].split()[0]
            except Exception:
                continue
            if state == "T" and pattern in p.name.lower():
                os.kill(pid, signal.SIGCONT)
                print(f"  Thawed {p.name} (PID {pid})")
                found = True
        if not found:
            print(f"  No frozen process matching '{args.name}'")
    else:
        count = 0
        for pid, p in d.procs.items():
            try:
                raw = _read_file(f"/proc/{pid}/stat")
                rp = raw.rindex(")")
                state = raw[rp + 2 :].split()[0]
            except Exception:
                continue
            if state == "T":
                try:
                    os.kill(pid, signal.SIGCONT)
                    count += 1
                except Exception:
                    pass
        print(f"  Thawed {count} processes")


def cmd_freeze(args):
    d = FrostByteDaemon()
    d.scan()
    pattern = args.name.lower()
    found = False
    for pid, p in sorted(d.procs.items(), key=lambda x: -x[1].rss_mb):
        if pattern in p.name.lower() and not d._is_whitelisted(p.name, p.cmdline):
            d.freeze_pid(pid, reason="manual")
            print(f"  Froze {p.name} (PID {pid}, {p.rss_mb:.0f}MB)")
            found = True
            break
    if not found:
        print(f"  No running process matching '{args.name}' (or it's whitelisted)")


_LOGO = [
    "  ╔═╗┬─┐┌─┐┌─┐┌┬┐╔╗ ┬ ┬┌┬┐┌─┐",
    "  ╠╣ ├┬┘│ │└─┐ │ ╠╩╗└┬┘ │ ├┤ ",
    "  ╚  ┴└─└─┘└─┘ ┴ ╚═╝ ┴  ┴ └─┘",
]

_LOGO_BIG = [" ".join(r) for r in zip(
    ["███████", "██     ", "█████  ", "██     ", "██     "],  # F
    ["██████ ", "██   ██", "██████ ", "██   ██", "██   ██"],  # R
    [" ██████ ", "██    ██", "██    ██", "██    ██", " ██████ "],  # O
    ["███████", "██     ", "███████", "     ██", "███████"],  # S
    ["████████", "   ██   ", "   ██   ", "   ██   ", "   ██   "],  # T
    ["██████ ", "██   ██", "██████ ", "██   ██", "██████ "],  # B
    ["██    ██", " ██  ██ ", "  ████  ", "   ██   ", "   ██   "],  # Y
    ["████████", "   ██   ", "   ██   ", "   ██   ", "   ██   "],  # T
    ["███████", "██     ", "█████  ", "██     ", "███████"],  # E
)]

_SNOW = "·  ❄  ·  ✦  ·  ❄  ·  ✦  ·  ❄  ·  ✦  ·  ❄  ·"

_STRINGS = {
    "en": {
        "ram_saved": "RAM Saved", "frozen": "Frozen", "candidates": "Candidates",
        "no_frozen": "No frozen processes", "no_candidates": "No candidates",
        "tab_frozen": " ❄ Frozen ({}) ", "tab_cand": " ◐ Candidates ({}) ",
        "tagline": "❄  auto-freeze for idle apps  ❄",
        "tagline_sm": "auto-freeze for idle apps",
        "proc": "proc", "procs": "procs", "idle": "idle",
        "btn_thaw": " Thaw ", "btn_freeze": " Freeze ", "btn_skip": " Skip ",
        "froze": "❄ Froze", "thawed": "✓ Thawed", "excluded": "⊘ Excluded",
        "already_excl": "already excluded",
        "no_match": "✗ No match", "no_frozen_match": "✗ No frozen match",
        "too_small": "Terminal too small",
        "k_quit": "quit", "k_action": "thaw/freeze", "k_select": "select",
        "k_switch": "switch", "k_freeze": "freeze", "k_thaw": "thaw",
        "k_exclude": "exclude", "k_lang": "язык",
        "freeze_prompt": "freeze ▸ ", "thaw_prompt": "thaw ▸ ",
        "tab_excl": " ⊘ Exclusions ({}) ", "no_excl": "No exclusions",
        "btn_remove": " Remove ", "removed": "✓ Removed",
    },
    "ru": {
        "ram_saved": "ОЗУ", "frozen": "Заморож.", "candidates": "Кандидаты",
        "no_frozen": "Нет замороженных", "no_candidates": "Нет кандидатов",
        "tab_frozen": " ❄ Заморож. ({}) ", "tab_cand": " ◐ Кандидаты ({}) ",
        "tagline": "❄  авто-заморозка неактивных приложений  ❄",
        "tagline_sm": "авто-заморозка приложений",
        "proc": "проц", "procs": "проц", "idle": "простой",
        "btn_thaw": " Разм. ", "btn_freeze": " Замор. ", "btn_skip": " Искл. ",
        "froze": "❄ Заморожен", "thawed": "✓ Разморожен", "excluded": "⊘ Исключён",
        "already_excl": "уже исключён",
        "no_match": "✗ Не найдено", "no_frozen_match": "✗ Нет замороженного",
        "too_small": "Терминал слишком мал",
        "k_quit": "выход", "k_action": "действие", "k_select": "выбор",
        "k_switch": "вкладка", "k_freeze": "замор.", "k_thaw": "разм.",
        "k_exclude": "искл.", "k_lang": "lang",
        "freeze_prompt": "заморозить ▸ ", "thaw_prompt": "разморозить ▸ ",
        "tab_excl": " ⊘ Исключения ({}) ", "no_excl": "Нет исключений",
        "btn_remove": " Убрать ", "removed": "✓ Убрано",
    },
}


def _monitor_tui(stdscr):
    """Live curses dashboard — modern TUI with visual blocks."""
    curses.use_default_colors()
    curses.curs_set(0)
    stdscr.timeout(33)  # ~30fps — instant hover response
    _MOUSE_MOVE = getattr(curses, 'REPORT_MOUSE_POSITION', 0)
    curses.mousemask(curses.ALL_MOUSE_EVENTS | _MOUSE_MOVE)
    # enable terminal-level mouse motion tracking (xterm any-event mode)
    sys.stdout.write('\033[?1003h')
    sys.stdout.flush()
    _B5 = getattr(curses, 'BUTTON5_PRESSED', curses.BUTTON4_PRESSED << 2)

    use_256 = curses.COLORS >= 256

    C_LOGO = 1; C_BORDER = 2; C_FROZEN = 3; C_CAND = 4
    C_STAT_VAL = 5; C_STAT_LBL = 6; C_BAR_FULL = 7; C_BAR_EMPTY = 8
    C_FOOTER = 9; C_FOOTER_KEY = 10; C_MSG = 11; C_SELECT = 12
    C_PROMPT = 13; C_HEAD = 14; C_DIM = 15; C_BAR_HOT = 16
    C_LOGO1 = 17; C_LOGO2 = 18; C_LOGO3 = 19; C_LOGO4 = 20; C_LOGO5 = 21
    C_BTN = 22; C_BTN_SKIP = 23; C_HOVER = 24

    if use_256:
        curses.init_pair(C_LOGO, 81, -1)
        curses.init_pair(C_BORDER, 239, -1)
        curses.init_pair(C_FROZEN, 75, -1)
        curses.init_pair(C_CAND, 222, -1)
        curses.init_pair(C_STAT_VAL, 114, -1)
        curses.init_pair(C_STAT_LBL, 245, -1)
        curses.init_pair(C_BAR_FULL, 75, -1)
        curses.init_pair(C_BAR_EMPTY, 238, -1)
        curses.init_pair(C_FOOTER, 252, 236)
        curses.init_pair(C_FOOTER_KEY, 81, 236)
        curses.init_pair(C_MSG, 222, -1)
        curses.init_pair(C_SELECT, 255, 237)
        curses.init_pair(C_PROMPT, 81, -1)
        curses.init_pair(C_HEAD, 252, -1)
        curses.init_pair(C_DIM, 242, -1)
        curses.init_pair(C_BAR_HOT, 203, -1)
        curses.init_pair(C_LOGO1, 159, -1)
        curses.init_pair(C_LOGO2, 123, -1)
        curses.init_pair(C_LOGO3, 87, -1)
        curses.init_pair(C_LOGO4, 81, -1)
        curses.init_pair(C_LOGO5, 75, -1)
        curses.init_pair(C_BTN, 81, 237)
        curses.init_pair(C_BTN_SKIP, 222, 237)
        curses.init_pair(C_HOVER, 252, 235)
    else:
        curses.init_pair(C_LOGO, curses.COLOR_CYAN, -1)
        curses.init_pair(C_BORDER, curses.COLOR_WHITE, -1)
        curses.init_pair(C_FROZEN, curses.COLOR_BLUE, -1)
        curses.init_pair(C_CAND, curses.COLOR_YELLOW, -1)
        curses.init_pair(C_STAT_VAL, curses.COLOR_GREEN, -1)
        curses.init_pair(C_STAT_LBL, curses.COLOR_WHITE, -1)
        curses.init_pair(C_BAR_FULL, curses.COLOR_CYAN, -1)
        curses.init_pair(C_BAR_EMPTY, curses.COLOR_WHITE, -1)
        curses.init_pair(C_FOOTER, curses.COLOR_WHITE, curses.COLOR_BLACK)
        curses.init_pair(C_FOOTER_KEY, curses.COLOR_CYAN, curses.COLOR_BLACK)
        curses.init_pair(C_MSG, curses.COLOR_YELLOW, -1)
        curses.init_pair(C_SELECT, curses.COLOR_WHITE, curses.COLOR_BLUE)
        curses.init_pair(C_PROMPT, curses.COLOR_CYAN, -1)
        curses.init_pair(C_HEAD, curses.COLOR_WHITE, -1)
        curses.init_pair(C_DIM, curses.COLOR_WHITE, -1)
        curses.init_pair(C_BAR_HOT, curses.COLOR_RED, -1)
        for cp in (C_LOGO1, C_LOGO2, C_LOGO3, C_LOGO4, C_LOGO5):
            curses.init_pair(cp, curses.COLOR_CYAN, -1)
        curses.init_pair(C_BTN, curses.COLOR_CYAN, curses.COLOR_BLACK)
        curses.init_pair(C_BTN_SKIP, curses.COLOR_YELLOW, curses.COLOR_BLACK)
        curses.init_pair(C_HOVER, curses.COLOR_WHITE, curses.COLOR_BLACK)

    _logo_grad = [C_LOGO1, C_LOGO2, C_LOGO3, C_LOGO4, C_LOGO5]

    bdr = curses.color_pair(C_BORDER)
    daemon = FrostByteDaemon()
    message = ""
    msg_time = 0.0
    tab = 0        # 0=frozen, 1=candidates, 2=exclusions
    sel = 0        # selected index in active tab
    scroll = 0     # scroll offset
    last_scan = 0.0
    _tab_row = -1
    _tab0_end = 0
    _tab1_start = 0
    _tab1_end = 0
    _tab2_start = 0
    _tab2_end = 0
    _block_y = []  # (y_start, y_end, index) for mouse click targets
    _btn_act = None   # (y, x_start, x_end) for action button
    _btn_skip = None  # (y, x_start, x_end) for skip button
    hover = -1        # block under mouse (visual only, separate from sel)
    lang = "en"
    S = _STRINGS[lang]
    _frame = 0
    _last_frame = 0.0

    def _framed(row, content="", attr=0):
        w = cols - 2
        _safe_addstr(stdscr, row, 0, "│", bdr)
        _safe_addstr(stdscr, row, 1, content[:w].ljust(w), attr)
        _safe_addstr(stdscr, row, cols - 1, "│", bdr)

    def _hline(row, left, right):
        line = left + "─" * max(0, cols - 2) + right
        _safe_addstr(stdscr, row, 0, line[:cols], bdr)

    def _fmt_mb(mb):
        return f"{mb / 1024:.1f} GB" if mb >= 1024 else f"{mb:.0f} MB"

    # cached data — only refreshed on scan
    frozen_list = []
    candidates = []
    saved_mb = 0.0
    fg_list = []
    cg_list = []

    while True:
        now_t = time.time()
        if now_t - last_scan >= 2.0:
            daemon.scan()
            last_scan = now_t
            now = time.time()
            threshold = daemon.config["freeze_after_minutes"]
            min_rss = daemon.config["min_rss_mb"]

            # ── collect data (only on scan) ──
            frozen_list = []
            candidates = []
            saved_mb = 0.0
            for pid, p in sorted(daemon.procs.items(), key=lambda x: -x[1].rss_mb):
                try:
                    raw = _read_file(f"/proc/{pid}/stat")
                    rp = raw.rindex(")")
                    state = raw[rp + 2:].split()[0]
                except Exception:
                    state = "?"
                if state == "T":
                    frozen_list.append((pid, p))
                    saved_mb += p.rss_mb
                elif not daemon._is_whitelisted(p.name, p.cmdline) and p.rss_mb >= min_rss:
                    idle_min = (now - p.last_active) / 60
                    candidates.append((pid, p, idle_min))
            candidates.sort(key=lambda x: -x[2])

            fg = {}
            for pid, p in frozen_list:
                g = fg.setdefault(p.name, {"name": p.name, "pids": [], "total_rss": 0.0})
                g["pids"].append(pid)
                g["total_rss"] += p.rss_mb
            fg_list = sorted(fg.values(), key=lambda g: -g["total_rss"])

            cg = {}
            for pid, p, idle in candidates:
                g = cg.setdefault(p.name, {"name": p.name, "pids": [], "total_rss": 0.0, "max_idle": 0.0})
                g["pids"].append(pid)
                g["total_rss"] += p.rss_mb
                g["max_idle"] = max(g["max_idle"], idle)
            cg_list = sorted(cg.values(), key=lambda g: -g["max_idle"])

        rows, cols = stdscr.getmaxyx()
        stdscr.erase()
        _btn_act = None
        _btn_skip = None
        _frame += 1

        if rows < 14 or cols < 60:
            _safe_addstr(stdscr, rows // 2, max(0, cols // 2 - 10),
                         S["too_small"], curses.color_pair(C_DIM))
            stdscr.refresh()
            key = stdscr.getch()
            if key in (ord("q"), 27):
                break
            continue

        threshold = daemon.config["freeze_after_minutes"]
        inner = cols - 2

        # ── items for current tab ──
        if tab == 0:
            items = fg_list
        elif tab == 1:
            items = cg_list
        else:
            items = [{"name": p} for p in daemon.config["whitelist"]]
        if sel >= len(items):
            sel = max(0, len(items) - 1)

        r = 0

        # ── top border ──
        _hline(r, "╭", "╮"); r += 1

        # ── logo (adaptive: big with gradient or compact) ──
        use_big = inner >= 77 and rows >= 24
        logo = _LOGO_BIG if use_big else _LOGO
        logo_w = max(len(l) for l in logo)
        lx = max(1, (cols - logo_w) // 2)

        if use_big:
            # snowflake decoration line
            sx = max(1, (cols - len(_SNOW)) // 2)
            _safe_addstr(stdscr, r, 0, "│", bdr)
            _safe_addstr(stdscr, r, sx, _SNOW[:inner],
                         curses.color_pair(C_DIM))
            _safe_addstr(stdscr, r, cols - 1, "│", bdr)
            r += 1

        _logo_shift = int(now_t * 0.15) % 5
        for i, line in enumerate(logo):
            _safe_addstr(stdscr, r + i, 0, "│", bdr)
            if use_big:
                lc = _logo_grad[(i + _logo_shift) % 5]
            else:
                lc = C_LOGO
            _safe_addstr(stdscr, r + i, lx, line,
                         curses.color_pair(lc) | curses.A_BOLD)
            _safe_addstr(stdscr, r + i, cols - 1, "│", bdr)
        r += len(logo)

        if use_big:
            # snowflake decoration line
            _safe_addstr(stdscr, r, 0, "│", bdr)
            _safe_addstr(stdscr, r, sx, _SNOW[:inner],
                         curses.color_pair(C_DIM))
            _safe_addstr(stdscr, r, cols - 1, "│", bdr)
            r += 1
            # tagline centered below logo
            tagline = S["tagline"]
            ttx = max(1, (cols - len(tagline)) // 2)
            _safe_addstr(stdscr, r, 0, "│", bdr)
            _safe_addstr(stdscr, r, ttx, tagline,
                         curses.color_pair(C_STAT_LBL))
            _safe_addstr(stdscr, r, cols - 1, "│", bdr)
            r += 1
        else:
            tagline = S["tagline_sm"]
            tx = cols - 2 - len(tagline) - 1
            if tx > lx + logo_w + 2:
                _safe_addstr(stdscr, r - 1, tx, tagline,
                             curses.color_pair(C_STAT_LBL))

        _framed(r); r += 1

        # ── stats ribbon ──
        _safe_addstr(stdscr, r, 0, "│", bdr)
        cx = 3
        for label, val in [(S["ram_saved"], _fmt_mb(saved_mb)),
                           (S["frozen"], str(len(frozen_list))),
                           (S["candidates"], str(len(candidates)))]:
            if cx + len(label) + len(val) + 2 >= cols - 1:
                break
            _safe_addstr(stdscr, r, cx, label, curses.color_pair(C_STAT_LBL))
            _safe_addstr(stdscr, r, cx + len(label) + 1, val,
                         curses.color_pair(C_STAT_VAL) | curses.A_BOLD)
            cx += len(label) + len(val) + 5
        _safe_addstr(stdscr, r, cols - 1, "│", bdr)
        r += 1

        _framed(r); r += 1

        # ── tab bar ──
        tab0 = S["tab_frozen"].format(len(frozen_list))
        tab1 = S["tab_cand"].format(len(candidates))
        tab2 = S["tab_excl"].format(len(daemon.config["whitelist"]))
        _safe_addstr(stdscr, r, 0, "│", bdr)
        t0x = 3
        _tab_labels = [(tab0, C_LOGO, 0), (tab1, C_CAND, 1), (tab2, C_DIM, 2)]
        tx = t0x
        _tab_row = r
        for tlbl, tcol, ti in _tab_labels:
            if ti == 0:
                _tab0_end = tx + len(tlbl)
            elif ti == 1:
                _tab1_start = tx; _tab1_end = tx + len(tlbl)
            else:
                _tab2_start = tx; _tab2_end = tx + len(tlbl)
            if tab == ti:
                _safe_addstr(stdscr, r, tx, tlbl,
                             curses.color_pair(tcol) | curses.A_BOLD | curses.A_UNDERLINE)
            else:
                _safe_addstr(stdscr, r, tx, tlbl, curses.color_pair(C_DIM))
            tx += len(tlbl) + 3
        _safe_addstr(stdscr, r, cols - 1, "│", bdr)
        r += 1

        # ── content divider ──
        _hline(r, "├", "┤"); r += 1

        # ── content area (blocks) ──
        content_top = r
        content_bot = rows - 3  # reserve: message + bottom border + footer
        content_h = content_bot - content_top
        BLOCK_H = 3  # name line + bar line + blank separator

        if content_h < 2 or not items:
            _block_y = []
            mid = content_top + content_h // 2
            empty = S["no_frozen"] if tab == 0 else (S["no_candidates"] if tab == 1 else S["no_excl"])
            for rr in range(content_top, content_bot):
                if rr == mid:
                    _framed(rr, f"   {empty}", curses.color_pair(C_DIM))
                else:
                    _framed(rr)
        else:
            max_vis = max(1, (content_h + 1) // BLOCK_H)

            # scroll management
            if sel < scroll:
                scroll = sel
            if sel >= scroll + max_vis:
                scroll = sel - max_vis + 1
            scroll = max(0, min(scroll, len(items) - max_vis))

            visible = items[scroll:scroll + max_vis]
            max_rss = max((g.get("total_rss", 0) for g in items), default=1)
            bar_w = max(8, inner - 6)  # full-width bar

            _block_y = []
            rr = content_top
            for vi, group in enumerate(visible):
                if rr + 1 >= content_bot:
                    break
                idx = scroll + vi
                _blk_y0 = rr
                is_sel = (idx == sel)
                is_hover = (idx == hover and not is_sel)
                name = group["name"]

                if tab == 2:
                    right = ""
                elif tab == 0:
                    rss_str = _fmt_mb(group["total_rss"])
                    n = len(group["pids"])
                    plbl = S["procs"] if n != 1 else S["proc"]
                    right = f"{rss_str}   {n} {plbl}"
                else:
                    rss_str = _fmt_mb(group["total_rss"])
                    idle = group["max_idle"]
                    right = f"{rss_str}   {S['idle']} {idle:.1f}m"

                left = f" ▸ {name}" if is_sel else (f" › {name}" if is_hover else f"   {name}")
                gap = inner - len(left) - len(right) - 1
                if gap < 1:
                    gap = 1

                # ── name line ──
                _safe_addstr(stdscr, rr, 0, "│", bdr)
                if is_sel:
                    if tab == 0:
                        btn_lbl = S["btn_thaw"]
                    elif tab == 1:
                        btn_lbl = S["btn_freeze"]
                    else:
                        btn_lbl = S["btn_remove"]
                    show_skip = (tab != 2)
                    if show_skip:
                        skip_lbl = S["btn_skip"]
                        skip_x = cols - 1 - len(skip_lbl)
                        act_x = skip_x - 1 - len(btn_lbl)
                    else:
                        act_x = cols - 1 - len(btn_lbl)
                    _safe_addstr(stdscr, rr, 1, " " * inner,
                                 curses.color_pair(C_SELECT))
                    _safe_addstr(stdscr, rr, 1, left[:inner],
                                 curses.color_pair(C_SELECT) | curses.A_BOLD)
                    rx = 1 + len(left) + gap
                    right_end = act_x - 1
                    if rx + len(right) <= right_end:
                        _safe_addstr(stdscr, rr, rx, right,
                                     curses.color_pair(C_SELECT))
                    _safe_addstr(stdscr, rr, act_x, btn_lbl,
                                 curses.color_pair(C_BTN) | curses.A_BOLD)
                    _btn_act = (rr, act_x, act_x + len(btn_lbl))
                    if show_skip:
                        _safe_addstr(stdscr, rr, skip_x, skip_lbl,
                                     curses.color_pair(C_BTN_SKIP) | curses.A_BOLD)
                        _btn_skip = (rr, skip_x, skip_x + len(skip_lbl))
                elif is_hover:
                    _safe_addstr(stdscr, rr, 1, " " * inner,
                                 curses.color_pair(C_HOVER))
                    _safe_addstr(stdscr, rr, 1, left[:inner],
                                 curses.color_pair(C_HOVER))
                    rx = 1 + len(left) + gap
                    if rx + len(right) < cols - 1:
                        _safe_addstr(stdscr, rr, rx, right,
                                     curses.color_pair(C_HOVER))
                else:
                    rc = C_FROZEN if tab == 0 else C_CAND
                    _safe_addstr(stdscr, rr, 1, left[:inner],
                                 curses.color_pair(rc))
                    rx = 1 + len(left) + gap
                    if rx + len(right) < cols - 1:
                        _safe_addstr(stdscr, rr, rx, right,
                                     curses.color_pair(C_HEAD))
                _safe_addstr(stdscr, rr, cols - 1, "│", bdr)
                rr += 1

                # ── bar line (full-width, skip for exclusions) ──
                if rr < content_bot and tab != 2:
                    _safe_addstr(stdscr, rr, 0, "│", bdr)
                    if is_sel:
                        _safe_addstr(stdscr, rr, 1, " " * inner,
                                     curses.color_pair(C_SELECT))
                    elif is_hover:
                        _safe_addstr(stdscr, rr, 1, " " * inner,
                                     curses.color_pair(C_HOVER))
                    bx = 4
                    avail = min(bar_w, cols - bx - 1)
                    if tab == 0:
                        filled = int(group["total_rss"] / max_rss * bar_w) if max_rss > 0 else 0
                        filled = max(1, min(avail, filled))
                        _safe_addstr(stdscr, rr, bx, "█" * filled,
                                     curses.color_pair(C_BAR_FULL))
                        if filled < avail:
                            _safe_addstr(stdscr, rr, bx + filled,
                                         "░" * (avail - filled),
                                         curses.color_pair(C_BAR_EMPTY))
                    else:
                        pct = group["max_idle"] / threshold if threshold > 0 else 0
                        filled = max(0, min(avail, int(pct * bar_w)))
                        # split bar into color zones
                        cut1 = int(0.5 * bar_w)
                        cut2 = int(0.8 * bar_w)
                        seg_end = [min(filled, cut1),
                                   min(filled, cut2),
                                   filled]
                        seg_start = [0, cut1, cut2]
                        seg_color = [C_BAR_FULL, C_CAND, C_BAR_HOT]
                        for si in range(3):
                            s0 = max(0, seg_start[si])
                            s1 = min(avail, seg_end[si])
                            if s1 > s0:
                                _safe_addstr(stdscr, rr, bx + s0,
                                             "█" * (s1 - s0),
                                             curses.color_pair(seg_color[si]))
                        if filled < avail:
                            _safe_addstr(stdscr, rr, bx + filled,
                                         "░" * (avail - filled),
                                         curses.color_pair(C_BAR_EMPTY))
                    _safe_addstr(stdscr, rr, cols - 1, "│", bdr)
                    rr += 1

                # ── separator ──
                if rr < content_bot and vi < len(visible) - 1:
                    _framed(rr)
                    rr += 1
                _block_y.append((_blk_y0, rr, idx))

            # fill remaining
            while rr < content_bot:
                _framed(rr)
                rr += 1

            # scroll indicators
            if scroll > 0:
                _safe_addstr(stdscr, content_top, cols - 2, "▲",
                             curses.color_pair(C_DIM))
            if scroll + max_vis < len(items):
                _safe_addstr(stdscr, content_bot - 1, cols - 2, "▼",
                             curses.color_pair(C_DIM))

        r = content_bot

        # ── message ──
        if message and now_t - msg_time > 5:
            message = ""
        _framed(r, f"  {message}" if message else "", curses.color_pair(C_MSG))
        r += 1

        # ── bottom border ──
        _hline(r, "╰", "╯"); r += 1

        # ── footer ──
        _safe_addstr(stdscr, rows - 1, 0, " " * cols, curses.color_pair(C_FOOTER))
        keys = [("q", S["k_quit"]), ("⏎/click", S["k_action"]),
                ("↑↓/scroll", S["k_select"]), ("tab", S["k_switch"]),
                ("f", S["k_freeze"]), ("t", S["k_thaw"]),
                ("e", S["k_exclude"]), ("L", S["k_lang"])]
        fx = 1
        for k, d in keys:
            if fx >= cols - 4:
                break
            _safe_addstr(stdscr, rows - 1, fx, f" {k} ",
                         curses.color_pair(C_FOOTER_KEY) | curses.A_BOLD)
            fx += len(k) + 2
            _safe_addstr(stdscr, rows - 1, fx, f"{d}  ",
                         curses.color_pair(C_FOOTER))
            fx += len(d) + 2

        stdscr.refresh()

        # ── input ──
        key = stdscr.getch()
        perform_action = False
        do_skip = False

        if key in (ord("q"), 27):
            sys.stdout.write('\033[?1003l')
            sys.stdout.flush()
            break
        elif key == ord("r"):
            message = ""
        elif key == curses.KEY_RESIZE:
            pass
        elif key == ord("\t") or key == curses.KEY_BTAB:
            tab = (tab + 1) % 3
            sel = 0
            scroll = 0
            hover = -1
        elif key == curses.KEY_UP:
            sel = max(0, sel - 1)
        elif key == curses.KEY_DOWN:
            sel = min(len(items) - 1, sel + 1) if items else 0
        elif key == curses.KEY_PPAGE:
            sel = max(0, sel - 5)
        elif key == curses.KEY_NPAGE:
            sel = min(len(items) - 1, sel + 5) if items else 0
        elif key in (ord("\n"), 10, 13):
            perform_action = True
        elif key == curses.KEY_MOUSE:
            try:
                _, mx, my, _, bstate = curses.getmouse()
                # always update hover on any mouse event
                hover = -1
                for y0, y1, bi in _block_y:
                    if y0 <= my < y1:
                        hover = bi
                        break
                # handle buttons/clicks
                _click = bstate & (curses.BUTTON1_PRESSED | curses.BUTTON1_CLICKED
                                   | curses.BUTTON1_DOUBLE_CLICKED)
                if bstate & curses.BUTTON4_PRESSED:
                    sel = max(0, sel - 1)
                elif bstate & _B5:
                    sel = min(len(items) - 1, sel + 1) if items else 0
                elif _click:
                    if my == _tab_row:
                        if 3 <= mx < _tab0_end:
                            tab = 0; sel = 0; scroll = 0; hover = -1
                        elif _tab1_start <= mx < _tab1_end:
                            tab = 1; sel = 0; scroll = 0; hover = -1
                        elif _tab2_start <= mx < _tab2_end:
                            tab = 2; sel = 0; scroll = 0; hover = -1
                    elif _btn_act and my == _btn_act[0] and _btn_act[1] <= mx < _btn_act[2]:
                        perform_action = True
                    elif _btn_skip and my == _btn_skip[0] and _btn_skip[1] <= mx < _btn_skip[2]:
                        do_skip = True
                    else:
                        for y0, y1, bi in _block_y:
                            if y0 <= my < y1:
                                if bi == sel:
                                    perform_action = True
                                else:
                                    sel = bi
                                break
            except curses.error:
                pass
        elif key == ord("L"):
            lang = "ru" if lang == "en" else "en"
            S = _STRINGS[lang]
        elif key == ord("e"):
            if items and 0 <= sel < len(items):
                do_skip = True
        elif key in (ord("f"), ord("t")):
            action = "freeze" if key == ord("f") else "thaw"
            curses.curs_set(1)
            curses.mousemask(0)
            prompt = "  " + (S["freeze_prompt"] if action == "freeze" else S["thaw_prompt"])
            mr = rows - 3
            _safe_addstr(stdscr, mr, 0, "│", bdr)
            _safe_addstr(stdscr, mr, 1, " " * (cols - 2), 0)
            _safe_addstr(stdscr, mr, 1, prompt,
                         curses.color_pair(C_PROMPT) | curses.A_BOLD)
            _safe_addstr(stdscr, mr, cols - 1, "│", bdr)
            stdscr.refresh()
            curses.echo()
            try:
                nb = stdscr.getstr(mr, 1 + len(prompt), 40)
            except curses.error:
                nb = b""
            curses.noecho()
            curses.curs_set(0)
            curses.mousemask(curses.ALL_MOUSE_EVENTS | _MOUSE_MOVE)
            sys.stdout.write('\033[?1003h')
            sys.stdout.flush()
            ni = nb.decode("utf-8", errors="replace").strip().lower()
            if ni:
                if action == "freeze":
                    match = None
                    for pid, p in sorted(daemon.procs.items(), key=lambda x: -x[1].rss_mb):
                        if ni in p.name.lower() and not daemon._is_whitelisted(p.name, p.cmdline):
                            match = (pid, p)
                            break
                    if match:
                        pid, p = match
                        daemon.freeze_pid(pid, reason="monitor")
                        message = f"{S['froze']} {p.name} (PID {pid})"
                    else:
                        message = f"{S['no_match']}: {ni}"
                else:
                    match = None
                    for pid, p in daemon.procs.items():
                        if ni in p.name.lower() and daemon._is_stopped(pid):
                            match = (pid, p)
                            break
                    if match:
                        pid, p = match
                        daemon.thaw_pid(pid)
                        message = f"{S['thawed']} {p.name} (PID {pid})"
                    else:
                        message = f"{S['no_frozen_match']}: {ni}"
                msg_time = now_t
            else:
                message = ""

        if perform_action and items and 0 <= sel < len(items):
            group = items[sel]
            if tab == 0:
                for pid in group["pids"]:
                    daemon.thaw_pid(pid)
                n = len(group["pids"])
                plbl = S["procs"] if n != 1 else S["proc"]
                message = f"{S['thawed']} {group['name']} ({n} {plbl})"
            elif tab == 1:
                for pid in group["pids"]:
                    daemon.freeze_pid(pid, reason="monitor")
                n = len(group["pids"])
                plbl = S["procs"] if n != 1 else S["proc"]
                message = f"{S['froze']} {group['name']} ({n} {plbl})"
            else:
                daemon.remove_from_whitelist(group["name"])
                message = f"{S['removed']} '{group['name']}'"
            msg_time = now_t
            last_scan = 0.0  # force data refresh

        if do_skip and tab != 2 and items and 0 <= sel < len(items):
            group = items[sel]
            if daemon.add_to_whitelist(group["name"]):
                message = f"{S['excluded']} '{group['name']}'"
            else:
                message = f"  '{group['name']}' {S['already_excl']}"
            msg_time = now_t
            last_scan = 0.0  # force data refresh


def cmd_monitor(args):
    curses.wrapper(_monitor_tui)


def main():
    parser = argparse.ArgumentParser(
        prog="frostbyte",
        description="Auto-suspend inactive apps to save RAM",
    )
    sub = parser.add_subparsers(dest="cmd")

    p_run = sub.add_parser("run", help="Start the daemon (foreground)")
    p_run.add_argument("--freeze-after", type=int, dest="freeze_after")
    p_run.add_argument("--min-rss", type=int, dest="min_rss")
    p_run.set_defaults(func=cmd_run)

    p_status = sub.add_parser("status", help="Show frozen & candidate processes")
    p_status.set_defaults(func=cmd_status)

    p_thaw = sub.add_parser("thaw", help="Thaw frozen processes")
    p_thaw.add_argument("name", nargs="?", help="Process name pattern (or all)")
    p_thaw.set_defaults(func=cmd_thaw)

    p_freeze = sub.add_parser("freeze", help="Manually freeze a process")
    p_freeze.add_argument("name", help="Process name pattern")
    p_freeze.set_defaults(func=cmd_freeze)

    p_monitor = sub.add_parser("monitor", help="Live TUI dashboard")
    p_monitor.set_defaults(func=cmd_monitor)

    args = parser.parse_args()
    if not args.cmd:
        parser.print_help()
        return
    args.func(args)


if __name__ == "__main__":
    main()
