#!/usr/bin/env python3
"""
FrostByte — auto-suspend inactive GUI apps to save RAM.
For GNOME on Wayland (Pop!_OS, Ubuntu, Fedora).

Monitors process CPU activity via /proc. After N minutes of inactivity,
sends SIGSTOP to freeze the process (and children). When the user focuses
the frozen window, the companion GNOME Shell extension writes the PID to
a temp file and the daemon instantly thaws it with SIGCONT.
"""

import os
import sys
import time
import signal
import json
import logging
import argparse
import curses
import math
import re
import subprocess
from pathlib import Path
from dataclasses import dataclass, field
from typing import Dict, Set, Optional, List

_UID = os.getuid()
_RUNTIME_DIR = Path(os.environ.get("XDG_RUNTIME_DIR", f"/run/user/{_UID}"))
FOCUS_FILE = _RUNTIME_DIR / "frostbyte-focus"
STATUS_FILE = _RUNTIME_DIR / "frostbyte-status.json"
THAW_FILE = _RUNTIME_DIR / "frostbyte-thaw"
CONFIG_DIR = Path.home() / ".config" / "frostbyte"
CONFIG_FILE = CONFIG_DIR / "config.json"
LOG_FILE = CONFIG_DIR / "frostbyte.log"
PID_FILE = _RUNTIME_DIR / "frostbyte.pid"
EXTENSION_UUID = "frostbyte@cryogen"
EXTENSION_DIR = (
    Path.home() / ".local" / "share" / "gnome-shell" / "extensions" / EXTENSION_UUID
)
SERVICE_DIR = Path.home() / ".config" / "systemd" / "user"
BIN_DIR = Path.home() / ".local" / "bin"

# Cache own source at module load time (needed for `curl | python3 - install`)
try:
    _SELF_PATH = Path(__file__).resolve()
    _SELF_SOURCE = _SELF_PATH.read_bytes() if _SELF_PATH.is_file() else None
except (NameError, OSError):
    _SELF_PATH = None
    _SELF_SOURCE = None

# ── Embedded resources (installed by `frostbyte install`) ────────────

_EXTENSION_JS = r'''import GLib from 'gi://GLib';
import Meta from 'gi://Meta';
import Clutter from 'gi://Clutter';
import St from 'gi://St';
import * as Main from 'resource:///org/gnome/shell/ui/main.js';
import * as PanelMenu from 'resource:///org/gnome/shell/ui/panelMenu.js';
import * as PopupMenu from 'resource:///org/gnome/shell/ui/popupMenu.js';
import {Extension} from 'resource:///org/gnome/shell/extensions/extension.js';

const RUNTIME_DIR = GLib.get_user_runtime_dir();
const FOCUS_FILE = `${RUNTIME_DIR}/frostbyte-focus`;
const STATUS_FILE = `${RUNTIME_DIR}/frostbyte-status.json`;
const THAW_FILE = `${RUNTIME_DIR}/frostbyte-thaw`;
const PID_FILE = `${RUNTIME_DIR}/frostbyte.pid`;

export default class FrostByteExtension extends Extension {
    enable() {
        // --- Ensure daemon is running ---
        try {
            if (!GLib.file_test(PID_FILE, GLib.FileTest.EXISTS)) {
                GLib.spawn_command_line_async(
                    'systemctl --user start frostbyte.service');
            }
        } catch (_) {}

        // --- Focus tracking ---
        this._focusId = global.display.connect('notify::focus-window', () => {
            const win = global.display.focus_window;
            if (win) this._writeFocus(win.get_pid());
        });

        this._captureId = global.stage.connect('captured-event', (actor, event) => {
            if (event.type() === Clutter.EventType.BUTTON_PRESS) {
                const [x, y] = event.get_coords();
                const pid = this._windowPidAtPos(x, y);
                if (pid > 0) this._writeFocus(pid);
            }
            return Clutter.EVENT_PROPAGATE;
        });

        // --- Panel indicator ---
        this._indicator = new PanelMenu.Button(0.0, 'FrostByte', false);

        this._icon = new St.Label({
            text: '\u2744',
            y_align: Clutter.ActorAlign.CENTER,
            style_class: 'system-status-icon',
            style: 'font-size: 16px; padding: 0 4px;',
        });
        this._indicator.add_child(this._icon);

        this._buildMenu();

        this._indicator.menu.connect('open-state-changed', (_menu, open) => {
            if (open) {
                this._refresh();
                this._pollId = GLib.timeout_add_seconds(
                    GLib.PRIORITY_DEFAULT, 3, () => {
                        if (this._indicator?.menu?.isOpen) {
                            this._refresh();
                            return GLib.SOURCE_CONTINUE;
                        }
                        return GLib.SOURCE_REMOVE;
                    });
            } else if (this._pollId) {
                GLib.source_remove(this._pollId);
                this._pollId = null;
            }
        });

        Main.panel.addToStatusArea('frostbyte', this._indicator);
    }

    _buildMenu() {
        const menu = this._indicator.menu;
        menu.removeAll();

        this._toggleItem = new PopupMenu.PopupSwitchMenuItem('FrostByte', true);
        this._toggleItem.connect('toggled', (_item, state) => {
            const cmd = state ? 'start' : 'stop';
            try {
                GLib.spawn_command_line_async(
                    `systemctl --user ${cmd} frostbyte.service`);
            } catch (_) {}
        });
        menu.addMenuItem(this._toggleItem);

        menu.addMenuItem(new PopupMenu.PopupSeparatorMenuItem());

        this._frozenSection = new PopupMenu.PopupMenuSection();
        menu.addMenuItem(this._frozenSection);

        menu.addMenuItem(new PopupMenu.PopupSeparatorMenuItem());
        this._footerItem = new PopupMenu.PopupMenuItem('', {reactive: false});
        this._footerItem.label.style = 'font-style: italic; color: #999;';
        menu.addMenuItem(this._footerItem);
    }

    _refresh() {
        try {
            const [ok, contents] = GLib.file_get_contents(STATUS_FILE);
            const data = JSON.parse(new TextDecoder().decode(contents));

            this._toggleItem.setToggleState(data.active !== false);

            this._frozenSection.removeAll();

            if (data.frozen && data.frozen.length > 0) {
                for (const proc of data.frozen) {
                    const item = new PopupMenu.PopupMenuItem(
                        `\u2744  ${proc.name}   ${proc.rss_mb} MB`);
                    item.connect('activate', () => {
                        this._requestThaw(proc.pid);
                    });
                    this._frozenSection.addMenuItem(item);
                }
                this._footerItem.label.text =
                    `Saved: ~${data.saved_mb} MB`;
            } else {
                const empty = new PopupMenu.PopupMenuItem(
                    'No frozen processes', {reactive: false});
                empty.label.style = 'font-style: italic; color: #888;';
                this._frozenSection.addMenuItem(empty);
                this._footerItem.label.text = '';
            }

            const count = data.frozen ? data.frozen.length : 0;
            this._icon.text = count > 0 ? `\u2744${count}` : '\u2744';

        } catch (_) {
            this._frozenSection.removeAll();
            const offline = new PopupMenu.PopupMenuItem(
                'Daemon not running', {reactive: false});
            offline.label.style = 'font-style: italic; color: #c62828;';
            this._frozenSection.addMenuItem(offline);
            this._toggleItem.setToggleState(false);
            this._icon.text = '\u2744';
            this._footerItem.label.text = '';
        }
    }

    _requestThaw(pid) {
        try {
            GLib.file_set_contents(THAW_FILE, `${pid}\n`);
        } catch (_) {}
    }

    _windowPidAtPos(x, y) {
        const actors = global.get_window_actors();
        for (let i = actors.length - 1; i >= 0; i--) {
            const win = actors[i].meta_window;
            if (!win) continue;
            if (win.get_window_type() !== Meta.WindowType.NORMAL) continue;
            const rect = win.get_frame_rect();
            if (x >= rect.x && x < rect.x + rect.width &&
                y >= rect.y && y < rect.y + rect.height)
                return win.get_pid();
        }
        return -1;
    }

    _writeFocus(pid) {
        if (pid > 0) {
            try {
                GLib.file_set_contents(FOCUS_FILE, `${pid}\n`);
            } catch (_) {}
        }
    }

    disable() {
        if (this._focusId) {
            global.display.disconnect(this._focusId);
            this._focusId = null;
        }
        if (this._captureId) {
            global.stage.disconnect(this._captureId);
            this._captureId = null;
        }
        if (this._pollId) {
            GLib.source_remove(this._pollId);
            this._pollId = null;
        }
        if (this._indicator) {
            this._indicator.destroy();
            this._indicator = null;
        }
        try { GLib.unlink(FOCUS_FILE); } catch (_) {}
    }
}
'''

_SERVICE_UNIT = """\
[Unit]
Description=FrostByte — auto-suspend inactive apps
After=graphical-session.target

[Service]
Type=simple
ExecStart=%h/.local/bin/frostbyte run
Restart=on-failure
RestartSec=5

[Install]
WantedBy=default.target
"""

DEFAULT_CONFIG = {
    "freeze_after_minutes": 10,
    "min_rss_mb": 100,
    "poll_interval": 1,
    "scan_interval": 30,
    "max_freeze_hours": 4,
    "whitelist": [
        # desktop shell & compositor
        "gnome-shell",
        "gnome-session",
        "gsd-",
        "mutter",
        "Xwayland",
        "kwin",
        "plasmashell",
        "sway",
        "hyprland",
        # input methods (keyboard switching breaks without these)
        "ibus",
        "fcitx",
        "xdg-desktop-portal",
        # audio
        "pulseaudio",
        "pipewire",
        "wireplumber",
        # terminals
        "tilix",
        "gnome-terminal",
        "kitty",
        "alacritty",
        "wezterm",
        "foot",
        # shells
        "bash",
        "zsh",
        "fish",
        # self
        "frostbyte",
        # VPN (substring match — covers AmneziaVPN, OpenVPN, NordVPN, etc.)
        "vpn",
        "wireguard",
        "wg-quick",
        # containers
        "docker",
        "containerd",
        "podman",
        # system
        "systemd",
        "dbus-daemon",
        "dbus-broker",
        "ssh",
        "sshd",
        "gpg-agent",
        "gnome-keyring",
        "polkit",
    ],
    "notifications": True,
    "rules": [],
}

PAGE_SIZE = os.sysconf("SC_PAGE_SIZE")


def _read_file(path: str) -> str:
    with open(path) as f:
        return f.read()


def _safe_addstr(win, y, x, text, attr=0):
    """Write text to curses window, silently ignoring out-of-bounds errors."""
    try:
        win.addstr(y, x, text, attr)
    except curses.error:
        pass


@dataclass
class Proc:
    pid: int
    name: str
    cmdline: str
    cpu: int
    rss_mb: float
    last_active: float
    frozen: bool = False


class FrostByteDaemon:
    def __init__(self, config_overrides: Optional[dict] = None):
        self.uid = os.getuid()
        self.procs: Dict[int, Proc] = {}
        self.frozen: Set[int] = set()
        self._frozen_at: Dict[int, float] = {}
        self._ppid_map: Dict[int, List[int]] = {}
        self.config = self._load_config()
        if config_overrides:
            self.config.update(config_overrides)
        self._validate_config()
        self._tick = 0
        self._should_exit = False
        self._config_mtime = 0.0
        self._audio_pids: Set[int] = set()
        self._compiled_rules: List[dict] = []
        self._compile_rules()

    # ── config ──────────────────────────────────────────────

    def _validate_config(self):
        cfg = self.config
        if cfg.get("poll_interval", 1) <= 0:
            cfg["poll_interval"] = 1
        if cfg.get("scan_interval", 30) <= 0:
            cfg["scan_interval"] = 30
        if cfg.get("freeze_after_minutes", 10) <= 0:
            cfg["freeze_after_minutes"] = 10
        if cfg.get("min_rss_mb", 100) < 0:
            cfg["min_rss_mb"] = 100
        if cfg.get("max_freeze_hours", 4) < 0:
            cfg["max_freeze_hours"] = 0

    def _load_config(self) -> dict:
        cfg = DEFAULT_CONFIG.copy()
        cfg["whitelist"] = list(DEFAULT_CONFIG["whitelist"])
        if CONFIG_FILE.exists():
            try:
                user = json.loads(CONFIG_FILE.read_text())
                user_wl = user.pop("whitelist", None)
                cfg.update(user)
                if user_wl is not None:
                    # merge: default whitelist + user additions
                    seen = {e.lower() for e in cfg["whitelist"]}
                    for entry in user_wl:
                        if entry.lower() not in seen:
                            cfg["whitelist"].append(entry)
                            seen.add(entry.lower())
            except Exception as e:
                logging.warning(f"Bad config {CONFIG_FILE}: {e} — using defaults")
        return cfg

    def _save_default_config(self):
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        if not CONFIG_FILE.exists():
            CONFIG_FILE.write_text(json.dumps(DEFAULT_CONFIG, indent=2) + "\n")

    def _save_config(self):
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        CONFIG_FILE.write_text(json.dumps(self.config, indent=2) + "\n")

    def add_to_whitelist(self, name):
        existing = [p.lower() for p in self.config["whitelist"]]
        if name.lower() not in existing:
            self.config["whitelist"].append(name)
            self._save_config()
            return True
        return False

    def remove_from_whitelist(self, name):
        low = name.lower()
        for i, entry in enumerate(self.config["whitelist"]):
            if entry.lower() == low:
                self.config["whitelist"].pop(i)
                self._save_config()
                return True
        return False

    # ── per-app rules ──────────────────────────────────────

    def _compile_rules(self):
        """Compile per-app rules from config into regex patterns."""
        compiled = []
        for rule in self.config.get("rules", []):
            pattern = rule.get("pattern", "")
            if not pattern:
                continue
            try:
                compiled.append({
                    "regex": re.compile(pattern, re.IGNORECASE),
                    "freeze_after_minutes": rule.get("freeze_after_minutes",
                                                      self.config["freeze_after_minutes"]),
                    "min_rss_mb": rule.get("min_rss_mb", self.config["min_rss_mb"]),
                })
            except re.error as e:
                logging.warning(f"Bad rule pattern {pattern!r}: {e}")
        self._compiled_rules = compiled

    # ── logging ─────────────────────────────────────────────

    def _setup_logging(self):
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        logging.basicConfig(
            level=logging.INFO,
            format="%(asctime)s %(message)s",
            datefmt="%H:%M:%S",
            handlers=[
                logging.FileHandler(LOG_FILE),
                logging.StreamHandler(sys.stdout),
            ],
        )

    # ── process scanning ────────────────────────────────────

    def _is_whitelisted(self, name: str, cmdline: str) -> bool:
        nl = name.lower()
        # match name and each argv token's basename, not raw substring of full cmdline
        tokens = cmdline.split() if cmdline.strip() else []
        bases = [t.rsplit("/", 1)[-1].lower() for t in tokens]
        for pat in self.config["whitelist"]:
            p = pat.lower()
            if p in nl or any(p in b for b in bases):
                return True
        return False

    def scan(self):
        """Read /proc and update internal process table."""
        now = time.time()
        seen: Set[int] = set()
        uid_prefix = f"Uid:\t{self.uid}\t"
        ppid_map: Dict[int, List[int]] = {}

        for entry in os.listdir("/proc"):
            if not entry.isdigit():
                continue
            pid = int(entry)
            try:
                raw = _read_file(f"/proc/{pid}/stat")
                lp = raw.index("(")
                rp = raw.rindex(")")
                comm = raw[lp + 1 : rp]
                f = raw[rp + 2 :].split()
                # f[0]=state f[1]=ppid f[2]=pgrp ... f[11]=utime f[12]=stime f[21]=rss
                state = f[0]
                ppid = int(f[1])

                status = _read_file(f"/proc/{pid}/status")
                if uid_prefix not in status:
                    continue
                # skip threads — only track thread group leaders (processes)
                if f"Tgid:\t{pid}\n" not in status:
                    continue

                cpu = int(f[11]) + int(f[12])
                rss = int(f[21]) * PAGE_SIZE / 1048576

                try:
                    cmdline = (
                        _read_file(f"/proc/{pid}/cmdline").replace("\0", " ").strip()
                    )
                except Exception:
                    cmdline = comm

                seen.add(pid)
                ppid_map.setdefault(ppid, []).append(pid)

                if pid in self.procs:
                    p = self.procs[pid]
                    if cpu != p.cpu:
                        p.last_active = now
                    p.cpu = cpu
                    p.rss_mb = rss
                    # detect externally-resumed processes
                    if p.frozen and state != "T":
                        p.frozen = False
                        self.frozen.discard(pid)
                else:
                    self.procs[pid] = Proc(
                        pid=pid,
                        name=comm,
                        cmdline=cmdline,
                        cpu=cpu,
                        rss_mb=rss,
                        last_active=now,
                    )
            except (FileNotFoundError, ProcessLookupError, ValueError,
                    IndexError, PermissionError):
                continue

        self._ppid_map = ppid_map

        # purge dead
        for pid in set(self.procs) - seen:
            del self.procs[pid]
            self.frozen.discard(pid)
            self._frozen_at.pop(pid, None)

    # ── freeze / thaw ──────────────────────────────────────

    def _children(self, pid: int, _visited: Optional[Set[int]] = None) -> List[int]:
        """Return list of all descendant PIDs (with cycle protection)."""
        if _visited is None:
            _visited = set()
        kids = []
        for child in self._ppid_map.get(pid, []):
            if child in _visited:
                continue
            _visited.add(child)
            kids.append(child)
            kids.extend(self._children(child, _visited))
        return kids

    def freeze_pid(self, pid: int, reason: str = ""):
        tree = [pid] + self._children(pid)
        count = 0
        for p in tree:
            # skip whitelisted children (e.g. terminal child apps)
            if p in self.procs and self._is_whitelisted(self.procs[p].name, self.procs[p].cmdline):
                if p != pid:
                    continue
            try:
                os.kill(p, signal.SIGSTOP)
                self.frozen.add(p)
                self._frozen_at.setdefault(p, time.time())
                if p in self.procs:
                    self.procs[p].frozen = True
                count += 1
            except (ProcessLookupError, PermissionError):
                pass
        if count:
            name = self.procs[pid].name if pid in self.procs else "?"
            rss = self.procs[pid].rss_mb if pid in self.procs else 0
            logging.info(
                f"FROZE  {name} pid={pid} ({count} procs, {rss:.0f}MB)"
                + (f" [{reason}]" if reason else "")
            )
            self._notify("Frozen", f"{name} ({rss:.0f} MB)")

    def _is_own_process(self, pid: int) -> bool:
        """Check if a process belongs to the current user."""
        try:
            return os.stat(f"/proc/{pid}").st_uid == self.uid
        except (FileNotFoundError, PermissionError):
            return False

    def thaw_pid(self, pid: int):
        # find the highest stopped ancestor to thaw the entire cluster
        root = pid
        visited = set()
        current = pid
        while current > 1 and current not in visited:
            if not self._is_own_process(current):
                break
            if self._is_stopped(current):
                root = current
            visited.add(current)
            try:
                raw = _read_file(f"/proc/{current}/stat")
                rp = raw.rindex(")")
                current = int(raw[rp + 2 :].split()[1])
            except Exception:
                break

        # collect all stopped processes in this tree
        to_thaw: Set[int] = set()
        if self._is_stopped(root):
            to_thaw.add(root)
        for p in self._children(root):
            if self._is_stopped(p):
                to_thaw.add(p)

        # children first: leaves thaw before roots, delay before root
        sorted_pids = sorted(list(to_thaw), key=lambda p: len(self._children(p)))
        thawed = []
        for i, p in enumerate(sorted_pids):
            # pause before the root process so children are schedulable
            if i == len(sorted_pids) - 1 and len(thawed) > 0:
                time.sleep(0.1) # increased slightly for stability
            try:
                os.kill(p, signal.SIGCONT)
                self.frozen.discard(p)
                self._frozen_at.pop(p, None)
                if p in self.procs:
                    self.procs[p].frozen = False
                    self.procs[p].last_active = time.time()
                thawed.append(p)
            except (ProcessLookupError, PermissionError):
                self.frozen.discard(p)
                self._frozen_at.pop(p, None)

        if thawed:
            name = self.procs[root].name if root in self.procs else "?"
            logging.info(f"THAW   {name} pid={root} ({len(thawed)} procs)")
            self._notify("Thawed", f"{name} ({len(thawed)} procs)")

    def thaw_all(self):
        self.scan()
        for pid in list(self.frozen):
            self.thaw_pid(pid)

    # ── focus tracking ──────────────────────────────────────

    def _is_stopped(self, pid: int) -> bool:
        """Check if a process is in T (stopped) state."""
        try:
            raw = _read_file(f"/proc/{pid}/stat")
            rp = raw.rindex(")")
            return raw[rp + 2 :].split()[0] == "T"
        except Exception:
            return False

    def _find_stopped_ancestor(self, pid: int) -> Optional[int]:
        """Walk up process tree to find a stopped (T) ancestor."""
        visited = set()
        current = pid
        while current > 1 and current not in visited:
            if self._is_stopped(current):
                return current
            visited.add(current)
            try:
                raw = _read_file(f"/proc/{current}/stat")
                rp = raw.rindex(")")
                current = int(raw[rp + 2 :].split()[1])
            except Exception:
                break
        return None

    def _check_focus(self):
        try:
            if FOCUS_FILE.exists():
                raw = FOCUS_FILE.read_text().strip()
                if raw:
                    pid = int(raw)
                    # check if this pid or any ancestor is actually stopped
                    stopped = self._find_stopped_ancestor(pid)
                    if stopped:
                        self.thaw_pid(stopped)
                    # also thaw stopped descendants (e.g. TUI apps inside a terminal)
                    for child in self._children(pid):
                        if self._is_stopped(child):
                            self.thaw_pid(child)
        except (ValueError, IOError):
            pass

    # ── auto-thaw (max freeze duration) ────────────────────

    def _check_auto_thaw(self):
        max_h = self.config.get("max_freeze_hours", 0)
        if max_h <= 0:
            return
        max_secs = max_h * 3600
        now = time.time()
        for pid in list(self.frozen):
            frozen_since = self._frozen_at.get(pid, now)
            if now - frozen_since >= max_secs:
                name = self.procs[pid].name if pid in self.procs else "?"
                logging.info(
                    f"AUTO-THAW {name} pid={pid} "
                    f"(frozen {(now - frozen_since) / 3600:.1f}h, limit={max_h}h)"
                )
                self.thaw_pid(pid)

    # ── freeze candidates ───────────────────────────────────

    def _check_freeze(self):
        now = time.time()
        threshold = self.config["freeze_after_minutes"] * 60
        min_rss = self.config["min_rss_mb"]

        for pid, p in list(self.procs.items()):
            if p.frozen:
                continue
            if self._is_whitelisted(p.name, p.cmdline):
                continue
            if pid in self._audio_pids:
                continue
            # per-app rules override global thresholds
            rule_threshold = threshold
            rule_min_rss = min_rss
            for rule in self._compiled_rules:
                if rule["regex"].search(p.name) or rule["regex"].search(p.cmdline):
                    rule_threshold = rule.get("freeze_after_minutes", self.config["freeze_after_minutes"]) * 60
                    rule_min_rss = rule.get("min_rss_mb", min_rss)
                    break
            if p.rss_mb < rule_min_rss:
                continue
            idle = now - p.last_active
            if idle >= rule_threshold:
                self.freeze_pid(
                    pid,
                    reason=f"idle {idle / 60:.0f}min, {p.rss_mb:.0f}MB",
                )

    # ── audio detection ────────────────────────────────────

    def _refresh_audio_pids(self):
        """Get PIDs currently producing audio via pactl/pw-dump."""
        pids = set()
        try:
            r = subprocess.run(
                ["pactl", "list", "sink-inputs"],
                capture_output=True, text=True, timeout=5,
            )
            if r.returncode == 0:
                for line in r.stdout.splitlines():
                    line = line.strip()
                    if line.startswith("application.process.id"):
                        val = line.split("=", 1)[-1].strip().strip('"')
                        try:
                            pids.add(int(val))
                        except ValueError:
                            pass
        except (FileNotFoundError, subprocess.TimeoutExpired):
            pass
        self._audio_pids = pids

    # ── notifications ─────────────────────────────────────

    def _notify(self, title: str, body: str):
        """Send desktop notification via notify-send (fire and forget)."""
        if not self.config.get("notifications", True):
            return
        try:
            subprocess.Popen(
                ["notify-send", "-a", "FrostByte", "-i", "dialog-information", title, body],
                stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
            )
        except FileNotFoundError:
            pass

    # ── config hot reload ─────────────────────────────────

    def _reload_config_if_changed(self):
        """Reload config if the file has been modified."""
        try:
            mt = CONFIG_FILE.stat().st_mtime
            if mt != self._config_mtime:
                self._config_mtime = mt
                old_cfg = self.config
                self.config = self._load_config()
                self._compile_rules()
                logging.info("Config reloaded")
        except OSError:
            pass

    # ── status + thaw-request ────────────────────────────────

    def _write_status(self):
        frozen_list = []
        saved_mb = 0
        for pid in list(self.frozen):
            if pid in self.procs:
                p = self.procs[pid]
                frozen_list.append({"pid": pid, "name": p.name, "rss_mb": round(p.rss_mb)})
                saved_mb += p.rss_mb
        data = {"frozen": frozen_list, "saved_mb": round(saved_mb), "active": True}
        try:
            STATUS_FILE.write_text(json.dumps(data) + "\n")
        except Exception:
            pass

    def _check_thaw(self):
        try:
            if THAW_FILE.exists():
                raw = THAW_FILE.read_text().strip()
                THAW_FILE.unlink(missing_ok=True)
                if raw:
                    pid = int(raw)
                    self.thaw_pid(pid)
        except (ValueError, IOError):
            pass

    # ── shutdown ────────────────────────────────────────────

    def _shutdown(self, signum, frame):
        self._should_exit = True

    def _clean_exit(self):
        """Graceful shutdown: thaw everything, clean up files."""
        logging.info("Shutting down — thawing all frozen processes")
        for pid in list(self.frozen):
            try:
                os.kill(pid, signal.SIGCONT)
                for child in self._children(pid):
                    try:
                        os.kill(child, signal.SIGCONT)
                    except Exception:
                        pass
            except Exception:
                pass
        try:
            STATUS_FILE.write_text(json.dumps({"frozen": [], "saved_mb": 0, "active": False}) + "\n")
        except Exception:
            pass
        THAW_FILE.unlink(missing_ok=True)
        PID_FILE.unlink(missing_ok=True)

    def _check_already_running(self):
        if PID_FILE.exists():
            try:
                old_pid = int(PID_FILE.read_text().strip())
                # verify the PID is actually a frostbyte process (not reused)
                try:
                    cmdline = _read_file(f"/proc/{old_pid}/cmdline")
                    if "frostbyte" not in cmdline:
                        return  # stale PID file, different process now
                except (FileNotFoundError, PermissionError):
                    return  # process gone
                os.kill(old_pid, 0)
                print(f"FrostByte already running (PID {old_pid})", file=sys.stderr)
                sys.exit(1)
            except (ProcessLookupError, ValueError):
                pass
            except PermissionError:
                print(f"FrostByte already running (PID {old_pid})", file=sys.stderr)
                sys.exit(1)

    # ── GNOME Shell extension ────────────────────────────────

    @staticmethod
    def _ensure_extension():
        """Enable the companion GNOME Shell extension if installed but inactive."""
        try:
            r = subprocess.run(
                ["gnome-extensions", "info", EXTENSION_UUID],
                capture_output=True, text=True, timeout=5,
            )
            if r.returncode != 0:
                logging.warning(
                    f"GNOME Shell extension {EXTENSION_UUID} not installed — "
                    f"focus-based thaw will not work"
                )
                return
            # "State: ENABLED" or locale-dependent "Включено: Да"
            enabled = ("ENABLED" in r.stdout or "Включено: Да" in r.stdout
                       or "Enabled: Yes" in r.stdout)
            if not enabled:
                subprocess.run(
                    ["gnome-extensions", "enable", EXTENSION_UUID],
                    capture_output=True, timeout=5,
                )
                logging.info(f"Enabled GNOME Shell extension {EXTENSION_UUID}")
        except FileNotFoundError:
            logging.warning("gnome-extensions CLI not found — cannot verify extension")
        except Exception as e:
            logging.warning(f"Extension check failed: {e}")

    # ── main loop ───────────────────────────────────────────

    def run(self):
        self._check_already_running()
        self._save_default_config()
        self._setup_logging()
        self._ensure_extension()
        signal.signal(signal.SIGTERM, self._shutdown)
        signal.signal(signal.SIGINT, self._shutdown)

        PID_FILE.write_text(str(os.getpid()))

        cfg = self.config
        logging.info(
            f"FrostByte started — freeze after {cfg['freeze_after_minutes']}min, "
            f"min RSS {cfg['min_rss_mb']}MB, "
            f"poll {cfg['poll_interval']}s, scan {cfg['scan_interval']}s"
        )

        scans_per_tick = max(1, cfg["scan_interval"] // cfg["poll_interval"])

        # thaw orphaned stopped processes from a previous daemon crash
        self.scan()
        for pid, p in self.procs.items():
            if self._is_stopped(pid):
                self.thaw_pid(pid)
                logging.info(f"ORPHAN-THAW {p.name} pid={pid}")

        try:
            while not self._should_exit:
                self._check_focus()
                self._check_thaw()

                self._tick += 1
                if self._tick >= scans_per_tick:
                    self._tick = 0
                    self.scan()
                    self._refresh_audio_pids()
                    self._check_freeze()
                    self._check_auto_thaw()
                    self._write_status()
                    self._reload_config_if_changed()

                time.sleep(cfg["poll_interval"])
        finally:
            self._clean_exit()

    # ── CLI helpers ─────────────────────────────────────────

    def print_status(self):
        self.scan()
        now = time.time()
        threshold = self.config["freeze_after_minutes"]
        min_rss = self.config["min_rss_mb"]

        # find frozen (T state) user processes
        frozen_list = []
        candidates = []
        for pid, p in sorted(self.procs.items(), key=lambda x: -x[1].rss_mb):
            try:
                raw = _read_file(f"/proc/{pid}/stat")
                rp = raw.rindex(")")
                state = raw[rp + 2 :].split()[0]
            except Exception:
                state = "?"

            if state == "T":
                frozen_list.append((pid, p))
            elif (
                not self._is_whitelisted(p.name, p.cmdline) and p.rss_mb >= min_rss
            ):
                idle = (now - p.last_active) / 60
                candidates.append((pid, p, idle))

        print(
            f"\n  Config: freeze after {threshold}min idle, "
            f"min RSS {min_rss}MB"
        )
        print(f"  Whitelist: {len(self.config['whitelist'])} patterns\n")

        if frozen_list:
            print(f"  FROZEN ({len(frozen_list)}):")
            for pid, p in frozen_list:
                print(f"    {pid:>7}  {p.rss_mb:>6.0f} MB  {p.name}")
        else:
            print("  FROZEN: none")

        print()
        if candidates:
            print(f"  CANDIDATES ({len(candidates)}):")
            for pid, p, idle in sorted(candidates, key=lambda x: -x[2])[:20]:
                bar_len = min(20, int(idle / threshold * 20))
                bar = "#" * bar_len + "-" * (20 - bar_len)
                print(
                    f"    {pid:>7}  {p.rss_mb:>6.0f} MB  "
                    f"idle {idle:>5.1f}m [{bar}] {p.name}"
                )
        else:
            print("  CANDIDATES: none (nothing above threshold)")
        print()


def cmd_run(args):
    overrides = {}
    if args.freeze_after is not None:
        overrides["freeze_after_minutes"] = args.freeze_after
    if args.min_rss is not None:
        overrides["min_rss_mb"] = args.min_rss
    daemon = FrostByteDaemon(overrides)
    daemon.run()


def cmd_status(args):
    FrostByteDaemon().print_status()


def cmd_thaw(args):
    d = FrostByteDaemon()
    d.scan()

    if args.name:
        pattern = args.name.lower()
        found = False
        for pid, p in d.procs.items():
            try:
                raw = _read_file(f"/proc/{pid}/stat")
                rp = raw.rindex(")")
                state = raw[rp + 2 :].split()[0]
            except Exception:
                continue
            if state == "T" and pattern in p.name.lower():
                d.thaw_pid(pid)
                print(f"  Thawed {p.name} (PID {pid})")
                found = True
        if not found:
            print(f"  No frozen process matching '{args.name}'")
    else:
        count = 0
        for pid, p in d.procs.items():
            if d._is_stopped(pid):
                d.thaw_pid(pid)
                count += 1
        print(f"  Thawed {count} processes")


def cmd_freeze(args):
    d = FrostByteDaemon()
    d.scan()
    pattern = args.name.lower()
    found = False
    for pid, p in sorted(d.procs.items(), key=lambda x: -x[1].rss_mb):
        if pattern in p.name.lower() and not d._is_whitelisted(p.name, p.cmdline):
            d.freeze_pid(pid, reason="manual")
            print(f"  Froze {p.name} (PID {pid}, {p.rss_mb:.0f}MB)")
            found = True
            break
    if not found:
        print(f"  No running process matching '{args.name}' (or it's whitelisted)")


_LOGO = [
    "  ╔═╗┬─┐┌─┐┌─┐┌┬┐╔╗ ┬ ┬┌┬┐┌─┐",
    "  ╠╣ ├┬┘│ │└─┐ │ ╠╩╗└┬┘ │ ├┤ ",
    "  ╚  ┴└─└─┘└─┘ ┴ ╚═╝ ┴  ┴ └─┘",
]

_LOGO_BIG = [" ".join(r) for r in zip(
    ["███████", "██     ", "█████  ", "██     ", "██     "],  # F
    ["██████ ", "██   ██", "██████ ", "██   ██", "██   ██"],  # R
    [" ██████ ", "██    ██", "██    ██", "██    ██", " ██████ "],  # O
    ["███████", "██     ", "███████", "     ██", "███████"],  # S
    ["████████", "   ██   ", "   ██   ", "   ██   ", "   ██   "],  # T
    ["██████ ", "██   ██", "██████ ", "██   ██", "██████ "],  # B
    ["██    ██", " ██  ██ ", "  ████  ", "   ██   ", "   ██   "],  # Y
    ["████████", "   ██   ", "   ██   ", "   ██   ", "   ██   "],  # T
    ["███████", "██     ", "█████  ", "██     ", "███████"],  # E
)]

_SNOW = "·  ❄  ·  ✦  ·  ❄  ·  ✦  ·  ❄  ·  ✦  ·  ❄  ·"

_STRINGS = {
    "en": {
        "ram_saved": "RAM Saved", "frozen": "Frozen", "candidates": "Candidates",
        "no_frozen": "No frozen processes", "no_candidates": "No candidates",
        "tab_frozen": " ❄ Frozen ({}) ", "tab_cand": " ◐ Candidates ({}) ",
        "tagline": "❄  auto-freeze for idle apps  ❄",
        "tagline_sm": "auto-freeze for idle apps",
        "proc": "proc", "procs": "procs", "idle": "idle",
        "btn_thaw": " Thaw ", "btn_freeze": " Freeze ", "btn_skip": " Skip ",
        "froze": "❄ Froze", "thawed": "✓ Thawed", "excluded": "⊘ Excluded",
        "already_excl": "already excluded",
        "no_match": "✗ No match", "no_frozen_match": "✗ No frozen match",
        "too_small": "Terminal too small",
        "k_quit": "quit", "k_action": "thaw/freeze", "k_select": "select",
        "k_switch": "switch", "k_freeze": "freeze", "k_thaw": "thaw",
        "k_exclude": "exclude", "k_lang": "язык",
        "freeze_prompt": "freeze ▸ ", "thaw_prompt": "thaw ▸ ",
        "tab_excl": " ⊘ Exclusions ({}) ", "no_excl": "No exclusions",
        "btn_remove": " Remove ", "removed": "✓ Removed",
    },
    "ru": {
        "ram_saved": "ОЗУ", "frozen": "Заморож.", "candidates": "Кандидаты",
        "no_frozen": "Нет замороженных", "no_candidates": "Нет кандидатов",
        "tab_frozen": " ❄ Заморож. ({}) ", "tab_cand": " ◐ Кандидаты ({}) ",
        "tagline": "❄  авто-заморозка неактивных приложений  ❄",
        "tagline_sm": "авто-заморозка приложений",
        "proc": "проц", "procs": "проц", "idle": "простой",
        "btn_thaw": " Разм. ", "btn_freeze": " Замор. ", "btn_skip": " Искл. ",
        "froze": "❄ Заморожен", "thawed": "✓ Разморожен", "excluded": "⊘ Исключён",
        "already_excl": "уже исключён",
        "no_match": "✗ Не найдено", "no_frozen_match": "✗ Нет замороженного",
        "too_small": "Терминал слишком мал",
        "k_quit": "выход", "k_action": "действие", "k_select": "выбор",
        "k_switch": "вкладка", "k_freeze": "замор.", "k_thaw": "разм.",
        "k_exclude": "искл.", "k_lang": "lang",
        "freeze_prompt": "заморозить ▸ ", "thaw_prompt": "разморозить ▸ ",
        "tab_excl": " ⊘ Исключения ({}) ", "no_excl": "Нет исключений",
        "btn_remove": " Убрать ", "removed": "✓ Убрано",
    },
}


def _monitor_tui(stdscr):
    """Live curses dashboard — modern TUI with visual blocks."""
    curses.use_default_colors()
    curses.curs_set(0)
    stdscr.timeout(33)  # ~30fps — instant hover response
    _REPORT = getattr(curses, 'REPORT_MOUSE_POSITION', 0)
    curses.mousemask(curses.ALL_MOUSE_EVENTS | _REPORT)
    # Enable any-event mouse tracking (motion without button press)
    print("\033[?1003h", end="", flush=True)
    _B5 = getattr(curses, 'BUTTON5_PRESSED', curses.BUTTON4_PRESSED << 2)

    use_256 = curses.COLORS >= 256

    C_LOGO = 1; C_BORDER = 2; C_FROZEN = 3; C_CAND = 4
    C_STAT_VAL = 5; C_STAT_LBL = 6; C_BAR_FULL = 7; C_BAR_EMPTY = 8
    C_FOOTER = 9; C_FOOTER_KEY = 10; C_MSG = 11; C_SELECT = 12
    C_PROMPT = 13; C_HEAD = 14; C_DIM = 15; C_BAR_HOT = 16
    C_LOGO1 = 17; C_LOGO2 = 18; C_LOGO3 = 19; C_LOGO4 = 20; C_LOGO5 = 21
    C_BTN = 22; C_BTN_SKIP = 23; C_HOVER = 24; C_BTN_HOV = 25
    C_ACCENT = 26; C_STAT_SEP = 27
    # overlay pairs: bar colors on selection / hover backgrounds
    C_BAR_FULL_S = 28; C_BAR_EMPTY_S = 29; C_BAR_HOT_S = 30; C_CAND_S = 31
    C_BAR_FULL_H = 32; C_BAR_EMPTY_H = 33; C_BAR_HOT_H = 34; C_CAND_H = 35
    C_STAT_LBL_S = 36; C_STAT_LBL_H = 37

    if use_256:
        curses.init_pair(C_LOGO, 81, -1)
        curses.init_pair(C_BORDER, 239, -1)
        curses.init_pair(C_FROZEN, 75, -1)
        curses.init_pair(C_CAND, 222, -1)
        curses.init_pair(C_STAT_VAL, 44, -1)
        curses.init_pair(C_STAT_LBL, 245, -1)
        curses.init_pair(C_BAR_FULL, 75, -1)
        curses.init_pair(C_BAR_EMPTY, 238, -1)
        curses.init_pair(C_FOOTER, 252, 233)
        curses.init_pair(C_FOOTER_KEY, 81, 233)
        curses.init_pair(C_MSG, 81, -1)
        curses.init_pair(C_SELECT, 255, 24)
        curses.init_pair(C_PROMPT, 81, -1)
        curses.init_pair(C_HEAD, 252, -1)
        curses.init_pair(C_DIM, 242, -1)
        curses.init_pair(C_BAR_HOT, 203, -1)
        curses.init_pair(C_LOGO1, 159, -1)
        curses.init_pair(C_LOGO2, 117, -1)
        curses.init_pair(C_LOGO3, 81, -1)
        curses.init_pair(C_LOGO4, 44, -1)
        curses.init_pair(C_LOGO5, 38, -1)
        curses.init_pair(C_BTN, 81, 235)
        curses.init_pair(C_BTN_SKIP, 222, 235)
        curses.init_pair(C_HOVER, 252, 235)
        curses.init_pair(C_BTN_HOV, 16, 81)
        curses.init_pair(C_ACCENT, 99, -1)
        curses.init_pair(C_STAT_SEP, 240, -1)
        # overlay pairs: bar fg on select bg (24) and hover bg (235)
        curses.init_pair(C_BAR_FULL_S, 75, 24)
        curses.init_pair(C_BAR_EMPTY_S, 238, 24)
        curses.init_pair(C_BAR_HOT_S, 203, 24)
        curses.init_pair(C_CAND_S, 222, 24)
        curses.init_pair(C_STAT_LBL_S, 245, 24)
        curses.init_pair(C_BAR_FULL_H, 75, 235)
        curses.init_pair(C_BAR_EMPTY_H, 238, 235)
        curses.init_pair(C_BAR_HOT_H, 203, 235)
        curses.init_pair(C_CAND_H, 222, 235)
        curses.init_pair(C_STAT_LBL_H, 245, 235)
    else:
        curses.init_pair(C_LOGO, curses.COLOR_CYAN, -1)
        curses.init_pair(C_BORDER, curses.COLOR_WHITE, -1)
        curses.init_pair(C_FROZEN, curses.COLOR_BLUE, -1)
        curses.init_pair(C_CAND, curses.COLOR_YELLOW, -1)
        curses.init_pair(C_STAT_VAL, curses.COLOR_GREEN, -1)
        curses.init_pair(C_STAT_LBL, curses.COLOR_WHITE, -1)
        curses.init_pair(C_BAR_FULL, curses.COLOR_CYAN, -1)
        curses.init_pair(C_BAR_EMPTY, curses.COLOR_WHITE, -1)
        curses.init_pair(C_FOOTER, curses.COLOR_WHITE, curses.COLOR_BLACK)
        curses.init_pair(C_FOOTER_KEY, curses.COLOR_CYAN, curses.COLOR_BLACK)
        curses.init_pair(C_MSG, curses.COLOR_YELLOW, -1)
        curses.init_pair(C_SELECT, curses.COLOR_WHITE, curses.COLOR_BLUE)
        curses.init_pair(C_PROMPT, curses.COLOR_CYAN, -1)
        curses.init_pair(C_HEAD, curses.COLOR_WHITE, -1)
        curses.init_pair(C_DIM, curses.COLOR_WHITE, -1)
        curses.init_pair(C_BAR_HOT, curses.COLOR_RED, -1)
        for cp in (C_LOGO1, C_LOGO2, C_LOGO3, C_LOGO4, C_LOGO5):
            curses.init_pair(cp, curses.COLOR_CYAN, -1)
        curses.init_pair(C_BTN, curses.COLOR_CYAN, curses.COLOR_BLACK)
        curses.init_pair(C_BTN_SKIP, curses.COLOR_YELLOW, curses.COLOR_BLACK)
        curses.init_pair(C_HOVER, curses.COLOR_WHITE, curses.COLOR_BLACK)
        curses.init_pair(C_ACCENT, curses.COLOR_MAGENTA, -1)
        curses.init_pair(C_STAT_SEP, curses.COLOR_WHITE, -1)
        curses.init_pair(C_BAR_FULL_S, curses.COLOR_CYAN, curses.COLOR_BLUE)
        curses.init_pair(C_BAR_EMPTY_S, curses.COLOR_WHITE, curses.COLOR_BLUE)
        curses.init_pair(C_BAR_HOT_S, curses.COLOR_RED, curses.COLOR_BLUE)
        curses.init_pair(C_CAND_S, curses.COLOR_YELLOW, curses.COLOR_BLUE)
        curses.init_pair(C_STAT_LBL_S, curses.COLOR_WHITE, curses.COLOR_BLUE)
        curses.init_pair(C_BAR_FULL_H, curses.COLOR_CYAN, curses.COLOR_BLACK)
        curses.init_pair(C_BAR_EMPTY_H, curses.COLOR_WHITE, curses.COLOR_BLACK)
        curses.init_pair(C_BAR_HOT_H, curses.COLOR_RED, curses.COLOR_BLACK)
        curses.init_pair(C_CAND_H, curses.COLOR_YELLOW, curses.COLOR_BLACK)
        curses.init_pair(C_STAT_LBL_H, curses.COLOR_WHITE, curses.COLOR_BLACK)
        curses.init_pair(C_BTN_HOV, curses.COLOR_BLACK, curses.COLOR_CYAN)

    _logo_grad = [C_LOGO1, C_LOGO2, C_LOGO3, C_LOGO4, C_LOGO5]

    bdr = curses.color_pair(C_BORDER)
    daemon = FrostByteDaemon()
    message = ""
    msg_time = 0.0
    tab = 0        # 0=frozen, 1=candidates, 2=exclusions
    sel = 0        # selected index in active tab
    scroll = 0     # scroll offset
    last_scan = 0.0
    _tab_row = -1
    _tab0_end = 0
    _tab1_start = 0
    _tab1_end = 0
    _tab2_start = 0
    _tab2_end = 0
    _block_y = []  # (y_start, y_end, index) for mouse click targets
    _row_btns = []    # [(y, x_start, x_end, index, "act"|"skip"), ...]
    hover = -1        # block under mouse (visual only, separate from sel)
    hover_btn = None  # (index, "act"|"skip") or None
    hover_tab = -1    # -1 or 0/1/2
    lang = "en"
    S = _STRINGS[lang]
    _frame = 0
    _last_frame = 0.0

    def _framed(row, content="", attr=0):
        w = cols - 2
        _safe_addstr(stdscr, row, 0, "│", bdr)
        _safe_addstr(stdscr, row, 1, content[:w].ljust(w), attr)
        _safe_addstr(stdscr, row, cols - 1, "│", bdr)

    def _hline(row, left, right):
        line = left + "─" * max(0, cols - 2) + right
        _safe_addstr(stdscr, row, 0, line[:cols], bdr)

    def _fmt_mb(mb):
        return f"{mb / 1024:.1f} GB" if mb >= 1024 else f"{mb:.0f} MB"

    # cached data — only refreshed on scan
    frozen_list = []
    candidates = []
    saved_mb = 0.0
    fg_list = []
    cg_list = []

    while True:
        now_t = time.time()
        if now_t - last_scan >= 2.0:
            daemon.scan()
            last_scan = now_t
            now = time.time()
            threshold = daemon.config["freeze_after_minutes"]
            min_rss = daemon.config["min_rss_mb"]

            # ── collect data (only on scan) ──
            frozen_list = []
            candidates = []
            saved_mb = 0.0
            for pid, p in sorted(daemon.procs.items(), key=lambda x: -x[1].rss_mb):
                try:
                    raw = _read_file(f"/proc/{pid}/stat")
                    rp = raw.rindex(")")
                    state = raw[rp + 2:].split()[0]
                except Exception:
                    state = "?"
                if state == "T":
                    frozen_list.append((pid, p))
                    saved_mb += p.rss_mb
                elif not daemon._is_whitelisted(p.name, p.cmdline) and p.rss_mb >= min_rss:
                    idle_min = (now - p.last_active) / 60
                    candidates.append((pid, p, idle_min))
            candidates.sort(key=lambda x: -x[2])

            fg = {}
            for pid, p in frozen_list:
                g = fg.setdefault(p.name, {"name": p.name, "pids": [], "total_rss": 0.0})
                g["pids"].append(pid)
                g["total_rss"] += p.rss_mb
            fg_list = sorted(fg.values(), key=lambda g: -g["total_rss"])

            cg = {}
            for pid, p, idle in candidates:
                g = cg.setdefault(p.name, {"name": p.name, "pids": [], "total_rss": 0.0, "max_idle": 0.0})
                g["pids"].append(pid)
                g["total_rss"] += p.rss_mb
                g["max_idle"] = max(g["max_idle"], idle)
            cg_list = sorted(cg.values(), key=lambda g: -g["max_idle"])

        rows, cols = stdscr.getmaxyx()
        stdscr.erase()
        _row_btns = []
        _frame += 1

        if rows < 14 or cols < 60:
            _safe_addstr(stdscr, rows // 2, max(0, cols // 2 - 10),
                         S["too_small"], curses.color_pair(C_DIM))
            stdscr.refresh()
            key = stdscr.getch()
            if key in (ord("q"), 27):
                break
            continue

        threshold = daemon.config["freeze_after_minutes"]
        inner = cols - 2

        # ── items for current tab ──
        if tab == 0:
            items = fg_list
        elif tab == 1:
            items = cg_list
        else:
            items = [{"name": p} for p in daemon.config["whitelist"]]
        if sel >= len(items):
            sel = max(0, len(items) - 1)

        r = 0

        # ── top border ──
        _hline(r, "╭", "╮"); r += 1

        # ── logo (adaptive: big with gradient or compact) ──
        use_big = inner >= 77 and rows >= 24
        logo = _LOGO_BIG if use_big else _LOGO
        logo_w = max(len(l) for l in logo)
        lx = max(1, (cols - logo_w) // 2)

        def _snow_line(row):
            sx = max(1, (cols - len(_SNOW)) // 2)
            _safe_addstr(stdscr, row, 0, "│", bdr)
            for ci, ch in enumerate(_SNOW):
                px = sx + ci
                if px >= cols - 1:
                    break
                if ch == "❄":
                    _safe_addstr(stdscr, row, px, ch,
                                 curses.color_pair(C_LOGO))
                elif ch == "✦":
                    _safe_addstr(stdscr, row, px, ch,
                                 curses.color_pair(C_ACCENT))
                else:
                    _safe_addstr(stdscr, row, px, ch,
                                 curses.color_pair(C_DIM))
            _safe_addstr(stdscr, row, cols - 1, "│", bdr)

        if use_big:
            _snow_line(r)
            r += 1

        _logo_shift = int(now_t * 0.15) % 5
        for i, line in enumerate(logo):
            _safe_addstr(stdscr, r + i, 0, "│", bdr)
            if use_big:
                lc = _logo_grad[(i + _logo_shift) % 5]
            else:
                lc = C_LOGO
            _safe_addstr(stdscr, r + i, lx, line,
                         curses.color_pair(lc) | curses.A_BOLD)
            _safe_addstr(stdscr, r + i, cols - 1, "│", bdr)
        r += len(logo)

        if use_big:
            _snow_line(r)
            r += 1
            # tagline centered below logo
            tagline = S["tagline"]
            ttx = max(1, (cols - len(tagline)) // 2)
            _safe_addstr(stdscr, r, 0, "│", bdr)
            _safe_addstr(stdscr, r, ttx, tagline,
                         curses.color_pair(C_STAT_LBL))
            _safe_addstr(stdscr, r, cols - 1, "│", bdr)
            r += 1
        else:
            tagline = S["tagline_sm"]
            tx = cols - 2 - len(tagline) - 1
            if tx > lx + logo_w + 2:
                _safe_addstr(stdscr, r - 1, tx, tagline,
                             curses.color_pair(C_STAT_LBL))

        _framed(r); r += 1

        # ── stats ribbon ──
        _safe_addstr(stdscr, r, 0, "│", bdr)
        cx = 3
        stats = [(S["ram_saved"], _fmt_mb(saved_mb)),
                 (S["frozen"], str(len(frozen_list))),
                 (S["candidates"], str(len(candidates)))]
        for si, (label, val) in enumerate(stats):
            if cx + len(label) + len(val) + 2 >= cols - 1:
                break
            _safe_addstr(stdscr, r, cx, label, curses.color_pair(C_STAT_LBL))
            _safe_addstr(stdscr, r, cx + len(label) + 1, val,
                         curses.color_pair(C_STAT_VAL) | curses.A_BOLD)
            cx += len(label) + len(val) + 3
            if si < len(stats) - 1 and cx < cols - 2:
                _safe_addstr(stdscr, r, cx, "│",
                             curses.color_pair(C_STAT_SEP))
                cx += 2
        # daemon status indicator
        ind = "❄ active"
        ind_c = C_LOGO
        if cx + 2 + len(ind) < cols - 1:
            _safe_addstr(stdscr, r, cx, "│",
                         curses.color_pair(C_STAT_SEP))
            _safe_addstr(stdscr, r, cx + 2, ind,
                         curses.color_pair(ind_c))
        _safe_addstr(stdscr, r, cols - 1, "│", bdr)
        r += 1

        _framed(r); r += 1

        # ── tab bar ──
        tab0 = S["tab_frozen"].format(len(frozen_list))
        tab1 = S["tab_cand"].format(len(candidates))
        tab2 = S["tab_excl"].format(len(daemon.config["whitelist"]))
        _safe_addstr(stdscr, r, 0, "│", bdr)
        t0x = 3
        _tab_labels = [(tab0, C_LOGO, 0), (tab1, C_CAND, 1), (tab2, C_DIM, 2)]
        tx = t0x
        _tab_row = r
        for tlbl, tcol, ti in _tab_labels:
            disp = ("● " + tlbl) if tab == ti else ("  " + tlbl)
            if ti == 0:
                _tab0_end = tx + len(disp)
            elif ti == 1:
                _tab1_start = tx; _tab1_end = tx + len(disp)
            else:
                _tab2_start = tx; _tab2_end = tx + len(disp)
            if tab == ti:
                _safe_addstr(stdscr, r, tx, disp,
                             curses.color_pair(tcol) | curses.A_BOLD | curses.A_UNDERLINE)
            elif hover_tab == ti:
                _safe_addstr(stdscr, r, tx, disp,
                             curses.color_pair(tcol) | curses.A_BOLD)
            else:
                _safe_addstr(stdscr, r, tx, disp, curses.color_pair(C_DIM))
            tx += len(disp) + 3
        _safe_addstr(stdscr, r, cols - 1, "│", bdr)
        r += 1

        # ── content divider ──
        _hline(r, "├", "┤"); r += 1

        # ── content area (blocks) ──
        content_top = r
        content_bot = rows - 3  # reserve: message + bottom border + footer
        content_h = content_bot - content_top
        BLOCK_H = 3  # name line + bar line + blank separator

        if content_h < 2 or not items:
            _block_y = []
            mid = content_top + content_h // 2
            empty = S["no_frozen"] if tab == 0 else (S["no_candidates"] if tab == 1 else S["no_excl"])
            for rr in range(content_top, content_bot):
                if rr == mid:
                    _framed(rr, f"   {empty}", curses.color_pair(C_DIM))
                else:
                    _framed(rr)
        else:
            max_vis = max(1, (content_h + 1) // BLOCK_H)

            # scroll management
            if sel < scroll:
                scroll = sel
            if sel >= scroll + max_vis:
                scroll = sel - max_vis + 1
            scroll = max(0, min(scroll, len(items) - max_vis))

            visible = items[scroll:scroll + max_vis]
            max_rss = max((g.get("total_rss", 0) for g in items), default=1)
            bar_w = max(8, inner - 18)  # leave room for label after bar

            _block_y = []
            rr = content_top
            for vi, group in enumerate(visible):
                if rr + 1 >= content_bot:
                    break
                idx = scroll + vi
                _blk_y0 = rr
                is_sel = (idx == sel)
                is_hover = (idx == hover and not is_sel)
                name = group["name"]

                if tab == 2:
                    right = ""
                elif tab == 0:
                    rss_str = _fmt_mb(group["total_rss"])
                    n = len(group["pids"])
                    plbl = S["procs"] if n != 1 else S["proc"]
                    right = f"{rss_str}   {n} {plbl}"
                else:
                    rss_str = _fmt_mb(group["total_rss"])
                    idle = group["max_idle"]
                    right = f"{rss_str}   {S['idle']} {idle:.1f}m"

                left = f" ▸ {name}" if is_sel else (f" › {name}" if is_hover else f"   {name}")

                # ── button layout (every row gets action btn) ──
                if tab == 0: btn_lbl = S["btn_thaw"]
                elif tab == 1: btn_lbl = S["btn_freeze"]
                else: btn_lbl = S["btn_remove"]
                show_skip = (is_sel and tab != 2)
                if show_skip:
                    skip_lbl = S["btn_skip"]
                    skip_x = cols - 1 - len(skip_lbl)
                    act_x = skip_x - 1 - len(btn_lbl)
                else:
                    act_x = cols - 1 - len(btn_lbl)
                _row_btns.append((rr, act_x, act_x + len(btn_lbl), idx, "act"))
                if show_skip:
                    _row_btns.append((rr, skip_x, skip_x + len(skip_lbl), idx, "skip"))

                is_act_hov = (hover_btn is not None and hover_btn[0] == idx
                              and hover_btn[1] == "act")
                is_skip_hov = (show_skip and hover_btn is not None
                               and hover_btn[0] == idx and hover_btn[1] == "skip")

                right_end = act_x - 1
                gap = right_end - 1 - len(left) - len(right)
                if gap < 1:
                    gap = 1

                # ── name line ──
                _safe_addstr(stdscr, rr, 0, "│", bdr)
                if is_sel:
                    _safe_addstr(stdscr, rr, 1, " " * inner,
                                 curses.color_pair(C_SELECT))
                    _safe_addstr(stdscr, rr, 1, left[:right_end - 1],
                                 curses.color_pair(C_SELECT) | curses.A_BOLD)
                    rx = 1 + len(left) + gap
                    if rx + len(right) <= right_end:
                        _safe_addstr(stdscr, rr, rx, right,
                                     curses.color_pair(C_SELECT))
                elif is_hover:
                    _safe_addstr(stdscr, rr, 1, " " * inner,
                                 curses.color_pair(C_HOVER))
                    _safe_addstr(stdscr, rr, 1, left[:right_end - 1],
                                 curses.color_pair(C_HOVER))
                    rx = 1 + len(left) + gap
                    if rx + len(right) <= right_end:
                        _safe_addstr(stdscr, rr, rx, right,
                                     curses.color_pair(C_HOVER))
                else:
                    rc = C_FROZEN if tab == 0 else (C_CAND if tab == 1 else C_DIM)
                    _safe_addstr(stdscr, rr, 1, left[:right_end - 1],
                                 curses.color_pair(rc))
                    rx = 1 + len(left) + gap
                    if rx + len(right) <= right_end:
                        _safe_addstr(stdscr, rr, rx, right,
                                     curses.color_pair(C_HEAD))

                # ── action button ──
                if is_act_hov:
                    ba = curses.color_pair(C_BTN_HOV) | curses.A_BOLD
                elif is_sel or is_hover:
                    ba = curses.color_pair(C_BTN) | curses.A_BOLD
                else:
                    ba = curses.color_pair(C_BTN)
                _safe_addstr(stdscr, rr, act_x, btn_lbl, ba)

                # ── skip button (selected row only) ──
                if show_skip:
                    if is_skip_hov:
                        sa = curses.color_pair(C_BTN_HOV) | curses.A_BOLD
                    else:
                        sa = curses.color_pair(C_BTN_SKIP) | curses.A_BOLD
                    _safe_addstr(stdscr, rr, skip_x, skip_lbl, sa)

                _safe_addstr(stdscr, rr, cols - 1, "│", bdr)
                rr += 1

                # ── bar line (full-width, skip for exclusions) ──
                if rr < content_bot and tab != 2:
                    _safe_addstr(stdscr, rr, 0, "│", bdr)
                    if is_sel:
                        _safe_addstr(stdscr, rr, 1, " " * inner,
                                     curses.color_pair(C_SELECT))
                        _bf = C_BAR_FULL_S; _be = C_BAR_EMPTY_S
                        _bh = C_BAR_HOT_S; _bc = C_CAND_S; _bl = C_STAT_LBL_S
                    elif is_hover:
                        _safe_addstr(stdscr, rr, 1, " " * inner,
                                     curses.color_pair(C_HOVER))
                        _bf = C_BAR_FULL_H; _be = C_BAR_EMPTY_H
                        _bh = C_BAR_HOT_H; _bc = C_CAND_H; _bl = C_STAT_LBL_H
                    else:
                        _bf = C_BAR_FULL; _be = C_BAR_EMPTY
                        _bh = C_BAR_HOT; _bc = C_CAND; _bl = C_STAT_LBL
                    bx = 4
                    avail = min(bar_w, cols - bx - 14)
                    if tab == 0:
                        filled = int(group["total_rss"] / max_rss * avail) if max_rss > 0 else 0
                        filled = max(1, min(avail, filled))
                        _safe_addstr(stdscr, rr, bx, "█" * filled,
                                     curses.color_pair(_bf))
                        if filled < avail:
                            _safe_addstr(stdscr, rr, bx + filled,
                                         "░" * (avail - filled),
                                         curses.color_pair(_be))
                        bar_lbl = _fmt_mb(group["total_rss"])
                    else:
                        pct = group["max_idle"] / threshold if threshold > 0 else 0
                        filled = max(0, min(avail, int(pct * avail)))
                        # split bar into color zones
                        cut1 = int(0.5 * avail)
                        cut2 = int(0.8 * avail)
                        seg_end = [min(filled, cut1),
                                   min(filled, cut2),
                                   filled]
                        seg_start = [0, cut1, cut2]
                        seg_color = [_bf, _bc, _bh]
                        for si in range(3):
                            s0 = max(0, seg_start[si])
                            s1 = min(avail, seg_end[si])
                            if s1 > s0:
                                _safe_addstr(stdscr, rr, bx + s0,
                                             "█" * (s1 - s0),
                                             curses.color_pair(seg_color[si]))
                        if filled < avail:
                            _safe_addstr(stdscr, rr, bx + filled,
                                         "░" * (avail - filled),
                                         curses.color_pair(_be))
                        bar_lbl = f"{group['max_idle']:.1f}m"
                    # label after bar
                    lbl_x = bx + avail + 2
                    if lbl_x + len(bar_lbl) < cols - 1:
                        _safe_addstr(stdscr, rr, lbl_x, bar_lbl,
                                     curses.color_pair(_bl))
                    _safe_addstr(stdscr, rr, cols - 1, "│", bdr)
                    rr += 1

                # ── separator ──
                if rr < content_bot and vi < len(visible) - 1:
                    _framed(rr)
                    rr += 1
                _block_y.append((_blk_y0, rr, idx))

            # fill remaining
            while rr < content_bot:
                _framed(rr)
                rr += 1

            # scroll indicators
            if scroll > 0:
                _safe_addstr(stdscr, content_top, cols - 2, "▲",
                             curses.color_pair(C_DIM))
            if scroll + max_vis < len(items):
                _safe_addstr(stdscr, content_bot - 1, cols - 2, "▼",
                             curses.color_pair(C_DIM))

        r = content_bot

        # ── message ──
        if message and now_t - msg_time > 5:
            message = ""
        _framed(r, f"  {message}" if message else "", curses.color_pair(C_MSG))
        r += 1

        # ── bottom border ──
        _hline(r, "╰", "╯"); r += 1

        # ── footer ──
        _safe_addstr(stdscr, rows - 1, 0, " " * cols, curses.color_pair(C_FOOTER))
        keys = [("q", S["k_quit"]), ("⏎", S["k_action"]),
                ("↑↓/scroll", S["k_select"]), ("tab", S["k_switch"]),
                ("f", S["k_freeze"]), ("t", S["k_thaw"]),
                ("e", S["k_exclude"]), ("L", S["k_lang"])]
        fx = 1
        for k, d in keys:
            if fx >= cols - 4:
                break
            _safe_addstr(stdscr, rows - 1, fx, f" {k} ",
                         curses.color_pair(C_FOOTER_KEY) | curses.A_BOLD)
            fx += len(k) + 2
            _safe_addstr(stdscr, rows - 1, fx, f"{d}  ",
                         curses.color_pair(C_FOOTER))
            fx += len(d) + 2

        stdscr.refresh()

        # ── input ──
        key = stdscr.getch()
        perform_action = False
        do_skip = False

        if key in (ord("q"), 27):
            break
        elif key == ord("r"):
            message = ""
        elif key == curses.KEY_RESIZE:
            pass
        elif key == ord("\t") or key == curses.KEY_BTAB:
            tab = (tab + 1) % 3
            sel = 0
            scroll = 0
            hover = -1
            hover_btn = None
        elif key == curses.KEY_UP:
            sel = max(0, sel - 1)
        elif key == curses.KEY_DOWN:
            sel = min(len(items) - 1, sel + 1) if items else 0
        elif key == curses.KEY_PPAGE:
            sel = max(0, sel - 5)
        elif key == curses.KEY_NPAGE:
            sel = min(len(items) - 1, sel + 5) if items else 0
        elif key in (ord("\n"), 10, 13):
            perform_action = True
        elif key == curses.KEY_MOUSE:
            try:
                _, mx, my, _, bstate = curses.getmouse()
                # ── update hover on every mouse event ──
                hover = -1
                hover_btn = None
                hover_tab = -1
                if my == _tab_row:
                    if 3 <= mx < _tab0_end:
                        hover_tab = 0
                    elif _tab1_start <= mx < _tab1_end:
                        hover_tab = 1
                    elif _tab2_start <= mx < _tab2_end:
                        hover_tab = 2
                for by, bx0, bx1, bidx, btype in _row_btns:
                    if my == by and bx0 <= mx < bx1:
                        hover_btn = (bidx, btype)
                        hover = bidx
                        break
                else:
                    for y0, y1, bi in _block_y:
                        if y0 <= my < y1:
                            hover = bi
                            break
                # ── handle clicks ──
                _click = bstate & (curses.BUTTON1_PRESSED | curses.BUTTON1_CLICKED
                                   | curses.BUTTON1_RELEASED | curses.BUTTON1_DOUBLE_CLICKED)
                if bstate & curses.BUTTON4_PRESSED:
                    sel = max(0, sel - 1)
                elif bstate & _B5:
                    sel = min(len(items) - 1, sel + 1) if items else 0
                elif _click:
                    if my == _tab_row:
                        if 3 <= mx < _tab0_end:
                            tab = 0; sel = 0; scroll = 0; hover = -1; hover_tab = -1
                        elif _tab1_start <= mx < _tab1_end:
                            tab = 1; sel = 0; scroll = 0; hover = -1; hover_tab = -1
                        elif _tab2_start <= mx < _tab2_end:
                            tab = 2; sel = 0; scroll = 0; hover = -1; hover_tab = -1
                    else:
                        btn_hit = False
                        for by, bx0, bx1, bidx, btype in _row_btns:
                            if my == by and bx0 <= mx < bx1:
                                sel = bidx
                                if btype == "act":
                                    perform_action = True
                                else:
                                    do_skip = True
                                btn_hit = True
                                break
                        if not btn_hit:
                            for y0, y1, bi in _block_y:
                                if y0 <= my < y1:
                                    sel = bi
                                    break
            except curses.error:
                pass
        elif key == ord("L"):
            lang = "ru" if lang == "en" else "en"
            S = _STRINGS[lang]
        elif key == ord("e"):
            if items and 0 <= sel < len(items):
                do_skip = True
        elif key in (ord("f"), ord("t")):
            action = "freeze" if key == ord("f") else "thaw"
            curses.curs_set(1)
            curses.mousemask(0)
            prompt = "  " + (S["freeze_prompt"] if action == "freeze" else S["thaw_prompt"])
            mr = rows - 3
            _safe_addstr(stdscr, mr, 0, "│", bdr)
            _safe_addstr(stdscr, mr, 1, " " * (cols - 2), 0)
            _safe_addstr(stdscr, mr, 1, prompt,
                         curses.color_pair(C_PROMPT) | curses.A_BOLD)
            _safe_addstr(stdscr, mr, cols - 1, "│", bdr)
            stdscr.refresh()
            curses.echo()
            try:
                nb = stdscr.getstr(mr, 1 + len(prompt), 40)
            except curses.error:
                nb = b""
            curses.noecho()
            curses.curs_set(0)
            curses.mousemask(curses.ALL_MOUSE_EVENTS | _REPORT)
            ni = nb.decode("utf-8", errors="replace").strip().lower()
            if ni:
                if action == "freeze":
                    match = None
                    for pid, p in sorted(daemon.procs.items(), key=lambda x: -x[1].rss_mb):
                        if ni in p.name.lower() and not daemon._is_whitelisted(p.name, p.cmdline):
                            match = (pid, p)
                            break
                    if match:
                        pid, p = match
                        daemon.freeze_pid(pid, reason="monitor")
                        message = f"{S['froze']} {p.name} (PID {pid})"
                    else:
                        message = f"{S['no_match']}: {ni}"
                else:
                    match = None
                    for pid, p in daemon.procs.items():
                        if ni in p.name.lower() and daemon._is_stopped(pid):
                            match = (pid, p)
                            break
                    if match:
                        pid, p = match
                        daemon.thaw_pid(pid)
                        message = f"{S['thawed']} {p.name} (PID {pid})"
                    else:
                        message = f"{S['no_frozen_match']}: {ni}"
                msg_time = now_t
            else:
                message = ""

        if perform_action and items and 0 <= sel < len(items):
            group = items[sel]
            if tab == 0:
                for pid in group["pids"]:
                    daemon.thaw_pid(pid)
                n = len(group["pids"])
                plbl = S["procs"] if n != 1 else S["proc"]
                message = f"{S['thawed']} {group['name']} ({n} {plbl})"
            elif tab == 1:
                for pid in group["pids"]:
                    daemon.freeze_pid(pid, reason="monitor")
                n = len(group["pids"])
                plbl = S["procs"] if n != 1 else S["proc"]
                message = f"{S['froze']} {group['name']} ({n} {plbl})"
            else:
                daemon.remove_from_whitelist(group["name"])
                message = f"{S['removed']} '{group['name']}'"
            msg_time = now_t
            last_scan = 0.0  # force data refresh

        if do_skip and tab != 2 and items and 0 <= sel < len(items):
            group = items[sel]
            if daemon.add_to_whitelist(group["name"]):
                message = f"{S['excluded']} '{group['name']}'"
            else:
                message = f"  '{group['name']}' {S['already_excl']}"
            msg_time = now_t
            last_scan = 0.0  # force data refresh


def cmd_monitor(args):
    try:
        curses.wrapper(_monitor_tui)
    finally:
        print("\033[?1003l", end="", flush=True)


def _detect_shell_versions():
    """Detect installed GNOME Shell version for metadata.json."""
    try:
        r = subprocess.run(
            ["gnome-shell", "--version"], capture_output=True, text=True, timeout=5,
        )
        # "GNOME Shell 46.0" → 46
        major = int(r.stdout.strip().split()[-1].split(".")[0])
        return [str(v) for v in range(max(45, major - 1), major + 2)]
    except Exception:
        return ["45", "46", "47", "48"]


def _ok(msg):
    print(f"  \033[32m✓\033[0m {msg}")

def _dim(msg):
    print(f"  \033[90m{msg}\033[0m")

def _warn(msg):
    print(f"  \033[33m!\033[0m {msg}")


def cmd_install(args):
    """Install FrostByte: binary, GNOME extension, systemd service."""
    print(f"\n  \033[36m❄\033[0m \033[1mFrostByte\033[0m installer\n")

    # 1. Copy binary
    BIN_DIR.mkdir(parents=True, exist_ok=True)
    dest = BIN_DIR / "frostbyte"

    if _SELF_PATH and dest.resolve() == _SELF_PATH:
        _dim(f"binary already at {dest}")
    elif _SELF_SOURCE:
        dest.write_bytes(_SELF_SOURCE)
        dest.chmod(0o755)
        _ok(f"daemon    → {dest}")
    else:
        sys.exit(
            "\033[31mError:\033[0m cannot locate script source (running from pipe?).\n"
            "Download the file first, then install:\n"
            "  curl -fsSL https://github.com/VladislavTsytrikov/frostbyte/raw/main/frostbyte -o /tmp/frostbyte\n"
            "  python3 /tmp/frostbyte install"
        )

    # 2. GNOME Shell extension
    EXTENSION_DIR.mkdir(parents=True, exist_ok=True)
    (EXTENSION_DIR / "extension.js").write_text(_EXTENSION_JS.lstrip("\n"))

    versions = _detect_shell_versions()
    metadata = {
        "uuid": EXTENSION_UUID,
        "name": "FrostByte Focus Tracker",
        "description": "Reports focused window PID to the FrostByte daemon for auto-thaw",
        "shell-version": versions,
        "version": 1,
    }
    (EXTENSION_DIR / "metadata.json").write_text(
        json.dumps(metadata, indent=2) + "\n"
    )
    _ok(f"extension → {EXTENSION_UUID} (GNOME Shell {', '.join(versions)})")

    # 3. Systemd service
    SERVICE_DIR.mkdir(parents=True, exist_ok=True)
    (SERVICE_DIR / "frostbyte.service").write_text(_SERVICE_UNIT)
    subprocess.run(["systemctl", "--user", "daemon-reload"],
                   capture_output=True, timeout=10)
    _ok("service   → frostbyte.service")

    # 4. Default config
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    if not CONFIG_FILE.exists():
        CONFIG_FILE.write_text(json.dumps(DEFAULT_CONFIG, indent=2) + "\n")
        _ok(f"config    → {CONFIG_FILE}")
    else:
        _dim(f"config already exists → {CONFIG_FILE}")

    # 5. Enable extension
    try:
        subprocess.run(
            ["gnome-extensions", "enable", EXTENSION_UUID],
            capture_output=True, timeout=5,
        )
        _ok("extension enabled")
    except FileNotFoundError:
        _warn("gnome-extensions not found — enable the extension manually")

    # 6. Enable & start service
    subprocess.run(
        ["systemctl", "--user", "enable", "--now", "frostbyte.service"],
        capture_output=True, timeout=10,
    )
    _ok("daemon started")

    print(f"\n  \033[32m\033[1mDone!\033[0m FrostByte is running. ❄")
    _dim("run \033[0mfrostbyte monitor\033[90m to open the TUI\n")


def cmd_uninstall(args):
    """Remove FrostByte: stop service, remove extension, binary, service."""
    import shutil

    print(f"\n  \033[36m❄\033[0m \033[1mFrostByte\033[0m uninstaller\n")

    # 1. Stop & disable service
    subprocess.run(
        ["systemctl", "--user", "disable", "--now", "frostbyte.service"],
        capture_output=True, timeout=10,
    )
    _ok("stopped frostbyte.service")

    # 2. Thaw everything before removing
    d = FrostByteDaemon()
    d.scan()
    count = 0
    for pid, p in d.procs.items():
        try:
            raw = _read_file(f"/proc/{pid}/stat")
            rp = raw.rindex(")")
            if raw[rp + 2:].split()[0] == "T":
                os.kill(pid, signal.SIGCONT)
                count += 1
        except Exception:
            continue
    if count:
        _ok(f"thawed {count} frozen processes")

    # 3. Disable & remove extension
    try:
        subprocess.run(
            ["gnome-extensions", "disable", EXTENSION_UUID],
            capture_output=True, timeout=5,
        )
    except FileNotFoundError:
        pass
    if EXTENSION_DIR.exists():
        shutil.rmtree(EXTENSION_DIR)
        _ok(f"removed extension {EXTENSION_UUID}")

    # 4. Remove service file
    svc = SERVICE_DIR / "frostbyte.service"
    if svc.exists():
        svc.unlink()
        subprocess.run(["systemctl", "--user", "daemon-reload"],
                       capture_output=True, timeout=10)
        _ok("removed frostbyte.service")

    # 5. Remove binary (but not if we're running from it — just warn)
    dest = BIN_DIR / "frostbyte"
    if dest.exists():
        if _SELF_PATH and dest.resolve() == _SELF_PATH:
            _warn(f"binary at {dest} — remove manually: rm {dest}")
        else:
            dest.unlink()
            _ok(f"removed {dest}")

    # 6. Clean tmp files
    for f in [FOCUS_FILE, STATUS_FILE, THAW_FILE, PID_FILE]:
        f.unlink(missing_ok=True)

    if args.purge and CONFIG_DIR.exists():
        shutil.rmtree(CONFIG_DIR)
        _ok("purged config directory")
    elif CONFIG_DIR.exists():
        _dim(f"config kept at {CONFIG_DIR} (use --purge to remove)")

    print(f"\n  \033[32m\033[1mDone!\033[0m FrostByte removed.\n")


def main():
    parser = argparse.ArgumentParser(
        prog="frostbyte",
        description="Auto-suspend inactive apps to save RAM",
        epilog=(
            "Quick install:\n"
            "  curl -fsSL https://github.com/VladislavTsytrikov/frostbyte/raw/main/frostbyte"
            " -o /tmp/frostbyte\n"
            "  python3 /tmp/frostbyte install\n"
        ),
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    sub = parser.add_subparsers(dest="cmd")

    p_run = sub.add_parser("run", help="Start the daemon (foreground)")
    p_run.add_argument("--freeze-after", type=int, dest="freeze_after")
    p_run.add_argument("--min-rss", type=int, dest="min_rss")
    p_run.set_defaults(func=cmd_run)

    p_status = sub.add_parser("status", help="Show frozen & candidate processes")
    p_status.set_defaults(func=cmd_status)

    p_thaw = sub.add_parser("thaw", help="Thaw frozen processes")
    p_thaw.add_argument("name", nargs="?", help="Process name pattern (or all)")
    p_thaw.set_defaults(func=cmd_thaw)

    p_freeze = sub.add_parser("freeze", help="Manually freeze a process")
    p_freeze.add_argument("name", help="Process name pattern")
    p_freeze.set_defaults(func=cmd_freeze)

    p_monitor = sub.add_parser("monitor", help="Live TUI dashboard")
    p_monitor.set_defaults(func=cmd_monitor)

    p_install = sub.add_parser(
        "install", help="Install everything: binary, extension, service")
    p_install.set_defaults(func=cmd_install)

    p_uninstall = sub.add_parser(
        "uninstall", help="Remove FrostByte completely")
    p_uninstall.add_argument(
        "--purge", action="store_true", help="Also remove config directory")
    p_uninstall.set_defaults(func=cmd_uninstall)

    args = parser.parse_args()
    if not args.cmd:
        parser.print_help()
        return
    args.func(args)


if __name__ == "__main__":
    main()
